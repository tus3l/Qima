<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>MathQimh â€” Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª (x â†’ a)</title>
  <meta name="description" content="ØªÙ…Ø§Ø±ÙŠÙ† ÙˆÙ†Ù‡Ø§ÙŠØ§Øª Ù…Ø«Ù„Ø«ÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ© Ù…Ø¹ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ ÙˆØ´Ø±Ø­ ÙˆØ®ÙŠØ§Ø±Ø§Øª ØªØ¯Ø±ÙŠØ¨ â€” MathQimh" />
  <link rel="canonical" href="https://mathqimh.com/" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://mathqimh.com/" />
  <meta property="og:title" content="MathQimh â€” Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª" />
  <meta property="og:description" content="ØªÙ…Ø§Ø±ÙŠÙ† ÙˆÙ†Ù‡Ø§ÙŠØ§Øª Ù…Ø«Ù„Ø«ÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ© Ù…Ø¹ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ ÙˆØ´Ø±Ø­ ÙˆØ®ÙŠØ§Ø±Ø§Øª ØªØ¯Ø±ÙŠØ¨" />
  <meta property="og:image" content="https://mathqimh.com/reactions/reaction101.jpg" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="MathQimh â€” Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª" />
  <meta name="twitter:description" content="ØªÙ…Ø§Ø±ÙŠÙ† ÙˆÙ†Ù‡Ø§ÙŠØ§Øª Ù…Ø«Ù„Ø«ÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ© Ù…Ø¹ Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ ÙˆØ´Ø±Ø­ ÙˆØ®ÙŠØ§Ø±Ø§Øª ØªØ¯Ø±ÙŠØ¨" />
  <meta name="twitter:image" content="https://mathqimh.com/reactions/reaction101.jpg" />
  <style>
    :root {
      --bg: #0b1220; --text: #e5e7eb; --muted: #94a3b8; --accent: #a78bfa;
      --glass-bg: rgba(17, 24, 39, 0.45); --glass-border: rgba(148, 163, 184, 0.4);
      --wm-color: rgba(229, 231, 235, 0.06);
    }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font-family: "Cairo", system-ui, -apple-system, Segoe UI, Tahoma, Arial; transition: background 300ms ease, color 300ms ease; }
    /* Mobile-safe areas and interaction */
    html, body { min-height: 100%; overscroll-behavior-y: none; }
    body { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }
    * { -webkit-tap-highlight-color: transparent; }
    .bg { position: fixed; inset: 0; z-index: -1; overflow: hidden; }
    .blob { position: absolute; width: 640px; height: 640px; border-radius: 50%;
      filter: blur(100px); opacity: .16; animation: float 18s ease-in-out infinite;
      pointer-events: none; mix-blend-mode: screen;
            -webkit-mask-image: radial-gradient(closest-side, rgba(0,0,0,.9), rgba(0,0,0,0));
              mask-image: radial-gradient(closest-side, rgba(0,0,0,.9), rgba(0,0,0,0)); }
    .b2 { background: #a78bfa; bottom: -280px; right: -240px; animation-delay: 4s; }
    .b3 { background: #5b7cff; top: 35%; left: -360px; animation-delay: 8s; }
    @keyframes float { 0%, 100% { transform: translate3d(0,0,0) scale(1);} 50% { transform: translate3d(40px, -30px, 0) scale(1.08);} }
    .container { max-width: 980px; margin: 40px auto; padding: 0 clamp(12px, 4vw, 24px); padding-left: max(clamp(12px, 4vw, 24px), env(safe-area-inset-left)); padding-right: max(clamp(12px, 4vw, 24px), env(safe-area-inset-right)); }
    .glass-card { backdrop-filter: blur(16px) saturate(180%); -webkit-backdrop-filter: blur(16px) saturate(180%);
      background-color: var(--glass-bg); border: 1px solid var(--glass-border); border-radius: 16px; padding: 20px; box-shadow: 0 8px 20px rgba(0,0,0,0.15); overflow:hidden; }
    h1 { margin-top:0; font-weight:700; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > * { flex:1 1 300px; }
    input, button { width: 100%; padding: 12px 14px; border-radius: 10px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.08); color: var(--text); font-size:16px; touch-action: manipulation; }
    button { background: var(--accent); color: white; border: none; cursor:pointer; transition: transform 160ms ease, box-shadow 160ms ease; min-height:48px; }
    button:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
    .center { text-align:center; }
    .reaction { font-size: 2rem; }
    img.reaction-img { width: 260px; max-width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 12px; border: 1px solid var(--glass-border); }
    /* Animations */
    .fade-in { animation: fadeIn 320ms ease-out; }
    @keyframes fadeIn { from { opacity:0; transform: translateY(8px) scale(.98);} to {opacity:1; transform: translateY(0) scale(1);} }
    @keyframes popIn { 0%{ transform: scale(.92);} 60%{ transform: scale(1.03);} 100%{ transform: scale(1);} }
    .reaction-img { animation: fadeIn 340ms ease-out; }
    .topbar { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom: 16px; }
    .topbar { position: relative; z-index: 100; }
    .toggle { display:flex; gap:8px; }
    .icon-btn { padding:8px 12px; border-radius: 10px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.08); color: var(--text); cursor:pointer; position: relative; z-index: 101; pointer-events: auto; }
    .segmented { display:flex; gap:8px; flex-wrap:wrap; width:100%; justify-content:flex-end; }
    .seg-btn { padding:12px 14px; border-radius:10px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.08); color: var(--text); cursor:pointer; min-height:48px; position: relative; z-index: 101; pointer-events: auto; }
    .seg-btn.active { background: var(--accent); color:white; }
    .control { display:flex; align-items:center; gap:10px; }
    input[type="range"] { width: 220px; accent-color: var(--accent); }
    .btn-outline { padding:8px 12px; border-radius:10px; border:1px solid var(--glass-border); background: transparent; color: var(--text); cursor:pointer; }
    .btn-outline:hover { background: rgba(255,255,255,0.08); }
    .overlay { position: fixed; inset:0; pointer-events:none; }
    .confetti { position:absolute; font-size: 22px; animation: fall 1000ms ease-in forwards; }
    @keyframes fall { 0%{ transform: translateY(-20px) rotate(0deg); opacity:1;} 100%{ transform: translateY(120px) rotate(360deg); opacity:0;} }
    /* Ù„ÙˆØ­Ø© Ø¥Ø¯Ø®Ø§Ù„ Ù…ØµØºÙ‘Ø±Ø© Ù„Ù„ÙƒØ³ÙˆØ± ÙˆØ§Ù„Ø£Ø³ ÙˆØ§Ù„Ø¬Ø°Ø± */
    .keypad { display:flex; gap:6px; margin-top:8px; flex-wrap:wrap; }
    .mini-btn { padding:6px 10px; border-radius:8px; border:1px solid var(--glass-border); background: rgba(255,255,255,0.08); color: var(--text); cursor:pointer; width:auto; }
    .mini-btn:hover { background: var(--accent); color:white; }
    .latin { direction:ltr; unicode-bidi: isolate; }
    /* Answer-area menu + tip */
    .ans-menu { position: relative; display:inline-block; margin: 6px 0; }
    .ans-menu-btn { width: 36px; height: 36px; border-radius: 10px; border:1px solid var(--glass-border); background: rgba(255,255,255,0.08); color: var(--text); display:flex; align-items:center; justify-content:center; font-size:18px; cursor:pointer; }
    .ans-menu-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,0.18); }
    .ans-menu-tip { position: absolute; bottom: 100%; inset-inline-start: 0; margin-bottom: 8px; z-index: 10; background: var(--glass-bg); color: var(--text); border:1px solid var(--glass-border); border-radius: 12px; padding: 6px 10px; box-shadow: 0 8px 20px rgba(0,0,0,0.18); font-size: 13px; max-width: 280px; display:none; }
    .ans-menu-tip:after { content: ''; position:absolute; inset-inline-start: 14px; top: 100%; width:0; height:0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid var(--glass-bg); }
    /* MathLive field styling */
    .mathfield { 
      display:block; width:100%; min-height:52px; padding:10px 12px; border-radius:10px; 
      border:1px solid #4A90E2; background: rgba(0,0,0,0.3); color: #ffffff !important; 
      font-size: clamp(20px, 5.5vw, 24px);
      /* MathLive theme variables for clear contrast */
      --ML__background: transparent;
      --ML__placeholder-background: rgba(255, 230, 109, 0.12);
      --ML__selection-background: rgba(167, 139, 250, 0.28);
      --ML__caret-color: #ffffff;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .mathfield-container { position: relative; }
    .kb-close-btn {
      position: fixed; right: 12px; bottom: 56px; z-index: 10000;
      padding: 6px 10px; border-radius: 12px;
      border: 1px solid var(--glass-border);
      background: var(--accent); color: #fff;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      display:none;
    }
    .kb-close-btn:hover { background: var(--accent); color: #fff; }
    .textfield { display:block; width:100%; min-height:56px; padding:12px 14px; border-radius:10px; border:2px solid #4A90E2; background:#ffffff; color:#000000; font-size: clamp(20px, 5.5vw, 24px); }
    /* Ø£Ø¸Ù‡Ø± ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù…Ø²Ø§ÙŠØ§ ÙƒØ§Ù…Ù„Ø© */
    /* (Ø¥Ø²Ø§Ù„Ø© Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„ÙŠØ³ØªØ¹ÙŠØ¯ Ø³Ù„ÙˆÙƒ MathLive Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ) */
    /* Ensure math text color is bright */
    .mathfield .ML__math, .mathfield .ML__content { color:#ffffff !important; }
    /* Ø¥ÙŠÙ‚Ø§Ù Ø£ÙŠ ØªÙ…ÙˆÙŠÙ‡ Ù„Ù„Ø®Ù„ÙÙŠØ© Ø®Ù„Ù ÙƒÙŠØ¨ÙˆØ±Ø¯ MathLive */
    .ML__keyboard { backdrop-filter: none !important; -webkit-backdrop-filter: none !important; border-radius: 0; box-shadow: none; background: transparent !important; }
    /* Ø¥Ø²Ø§Ù„Ø© ÙØ±Ø¶ Ø§Ù„ØªÙ…ÙˆØ¶Ø¹ Ø§Ù„Ø³ÙÙ„ÙŠ Ø§Ù„Ø«Ø§Ø¨Øª Ù„Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ Ù„Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ */
    /* Ø¥Ø²Ø§Ù„Ø© Ù‚ÙŠÙˆØ¯ Ø§Ù„Ù€ slot ÙˆØ§Ù„Ù€ body Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ Ù„Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ */
    /* Dismiss button to close keyboard */
    .kb-dismiss { position: fixed; right: 12px; bottom: 56px; z-index: 10000; padding: 8px 12px; border-radius: 999px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.12); color: var(--text); box-shadow: 0 6px 18px rgba(0,0,0,0.18); display:none; }
    .kb-dismiss:hover { background: var(--accent); color: #fff; }
    /* Container uses dynamic viewport height */
    .container { min-height: 100dvh; }
    /* ØªØ­Ø³ÙŠÙ† ÙˆØ¶ÙˆØ­ Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„ÙƒØ³Ø± (Placeholders) ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø§ÙƒÙ† */
    .mathfield .ML__placeholder { background: transparent !important; box-shadow: none; border-radius: 6px; }
    .mathfield .ML__placeholder.ML__empty { 
      background: rgba(255,230,109,0.12) !important;
      box-shadow: inset 0 0 0 2px #FFE66D;
      min-width: 20px; min-height: 24px;
    }
    .mathfield .ML__placeholder:not(.ML__empty) { background: transparent !important; box-shadow: none; }
    /* Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ Ø®Ù„ÙÙŠØ© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù‚Ø¯ ØªØ¸Ù‡Ø± Ø®Ù„Ù Ø§Ù„Ø¨Ø³Ø·/Ø§Ù„Ù…Ù‚Ø§Ù… Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙƒØªØ§Ø¨Ø© */
    .mathfield .ML__box,
    .mathfield .ML__content,
    .mathfield .ML__math,
    .mathfield .ML__numerator,
    .mathfield .ML__denominator,
    .mathfield .ML__group { background-color: transparent !important; }
    .mathfield .ML__group.ML__active,
    .mathfield .ML__group.ML__focused,
    .mathfield .ML__box.ML__active,
    .mathfield .ML__box.ML__focused { background-color: transparent !important; }
    /* Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ ØªØ¹Ø¨Ø¦Ø© Ø¯Ø§Ø®Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙƒØªØ§Ø¨Ø© */
    .mathfield .ML__box .ML__content { background-color: transparent !important; }
    /* ØªØ£ÙƒÙŠØ¯ Ø¹Ø¯Ù… Ø¸Ù‡ÙˆØ± Ø®Ù„ÙÙŠØ© Ù„Ø£ÙŠ Ø¹Ù†ØµØ± Ù…Ø­Ø¯Ø¯/Ù…Ø±ÙƒÙ‘Ø² ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø§ÙƒÙ† */
    .mathfield .ML__selected,
    .mathfield .ML__focus { background-color: transparent !important; }
    .mathfield .ML__selection { background: rgba(167, 139, 250, 0.25); }
    .mathfield .ML__caret { border-left-color: #ffffff; }
    /* Ø´Ø§Ø±Ø§Øª ØµØºÙŠØ±Ø© Ù„Ù„Ù…ÙŠØªØ±ÙƒØ² */
    #streakLabel, #accLabel { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.05); }
    /* Ø®Ù„ÙÙŠØ© Ù†ØµÙŠØ© Ø´ÙØ§ÙØ© Ù„ÙƒÙ„Ù…Ø§Øª sin/cos/tan */
    .wm { position: fixed; inset:0; z-index: -1; pointer-events:none; }
    .wm span { position:absolute; color: var(--wm-color); font-weight:700; letter-spacing: .08em; user-select:none; filter: blur(.2px); font-size: clamp(18px, 6vw, 44px); }
    /* ÙƒØ±ÙˆØª Ù†ØªÙŠØ¬Ø© Ù…Ù…ÙŠØ²Ø© ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ */
    .success-card { box-shadow: 0 10px 30px rgba(16,185,129,.18), inset 0 0 0 1px rgba(16,185,129,.25); }
    .fail-card { box-shadow: 0 10px 30px rgba(239,68,68,.18), inset 0 0 0 1px rgba(239,68,68,.25); }
    .headline { font-size: clamp(18px, 2.4vw, 22px); font-weight: 700; }
    /* ÙˆØµÙ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: Ø³Ø·Ø± Ø¹Ù„ÙˆÙŠ ÙƒØ¨ÙŠØ± Ù„Ù„Ù‚ÙˆØ³ÙŠÙ† ÙˆØ³Ø·Ø± Ø³ÙÙ„ÙŠ Ù„Ù„ÙˆØµÙ */
    #desc { display:flex; flex-direction: column; gap:6px; }
    #desc .desc-tag { font-weight:700; color: var(--text); font-size: clamp(22px, 3.2vw, 30px); line-height: 1.15; }
    #desc .desc-base { color: var(--muted); font-size: clamp(14px, 1.6vw, 18px); }
    /* Ø®ÙØ¶ Ø§Ù„ØªØ£Ø«ÙŠØ± ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ù‚ØµÙŠØ±Ø© Ø£Ùˆ Ø§Ù„ØµØºÙŠØ±Ø© */
    @media (max-width: 768px), (max-height: 820px) {
      .blob { opacity: .12; filter: blur(80px); width: 520px; height: 520px; }
      .b2 { bottom: -340px; right: -260px; }
      .b3 { display:none; }
    }
    .scorebar { display:flex; align-items:center; gap:12px; }
    .bar { flex:1; height: 10px; border-radius: 999px; background: rgba(255,255,255,0.12); overflow:hidden; }
    .bar > span { display:block; height:100%; width:0%; background: var(--accent); transition: width 300ms ease; }
    .score { min-width: 120px; }
    @media (prefers-reduced-motion: reduce) {
      .blob, .fade-in, .pop-in, .reaction-img, .confetti { animation: none !important; }
      html, body { transition: none; }
    }
    /* ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„Ø¬ÙˆØ§Ù„Ø§Øª */
    @media (max-width: 640px) {
      .topbar { flex-wrap: wrap; gap:10px; }
      .segmented { justify-content: space-between; width: 100%; }
      #modeSeg .seg-btn { flex:1 1 auto; }
      .row > * { flex: 1 1 100%; }
      #pointSeg { width:100%; justify-content: space-between; }
      #pointSeg .seg-btn { flex: 1 1 calc(33.333% - 8px); }
      button, .seg-btn { font-size: 1rem; }
    }
    @media (max-width: 380px) {
      button, .seg-btn { padding: 10px 12px; }
      .textfield, .mathfield { min-height: 52px; }
    }
    /* === Graph mobile responsiveness === */
    #graph { height: 420px; }
    /* Read-only solution graph under the answer */
    #solutionGraph { width: 100%; height: 260px; }
    /* Training mode compact graph above the button */
    #trainGraph { width: 100%; height: 220px; }
    @media (max-width: 640px) {
      /* Make the graph fill a sensible portion of the viewport */
      #graph { height: clamp(260px, 50dvh, 520px) !important; }
      #solutionGraph { height: clamp(200px, 38dvh, 360px) !important; }
      #trainGraph { height: clamp(180px, 34dvh, 320px) !important; }
      #graphCard .row { gap: 8px; }
      #graphCard .control { flex-wrap: wrap; }
      #graphCard input[type="range"] { width: 100%; }
      #graphCard input[type="checkbox"] { width: 22px; height: 22px; }
      #graphCard label { line-height: 1.3; }
    }
    /* Prevent any annotation from intercepting clicks */
    .plotly .annotation { pointer-events: none !important; }
    /* Clip any Plotly layers to the graph bounds */
    #graph, #solutionGraph, #calcGraph, #trainGraph { position: relative; overflow: hidden; }
    /* Extra safety: disable pointer events on floating UI layers of Plotly */
    .js-plotly-plot .modebar, .js-plotly-plot .hoverlayer, .js-plotly-plot .select-outline, .js-plotly-plot .zoomlayer { pointer-events: none !important; }
    /* Decisive fix: make graphs non-interactive to never block clicks (can re-enable later) */
    #graph, #solutionGraph, #calcGraph, #trainGraph { pointer-events: none !important; }
    /* === Explicit high-contrast overrides requested === */
    math-field {
      color: #000000 !important;
      background-color: #ffffff !important;
      border: 2px solid #4A90E2 !important;
      font-size: 1.5rem !important;
      display: block; width: 100%;
      --caret-color: #ff0000 !important; /* some builds use this var */
      --ML__caret-color: #ff0000 !important; /* MathLive caret color */
    }
    math-field::part(content) { color: #000000 !important; }
    math-field::part(placeholder) { color: #4A90E2 !important; opacity: 0.8; }
    math-field:focus-within {
      outline: 2px solid #ffaa00 !important;
      background-color: #f0f8ff !important;
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
  <!-- MathLive for WYSIWYG math input -->
  <link rel="stylesheet" href="https://unpkg.com/mathlive/dist/mathlive.min.css">
  <script type="module">import 'https://unpkg.com/mathlive?module';</script>
  <!-- Plotly for interactive graphing -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <!-- Pyodide for in-browser Python + SymPy -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
  <div class="bg"><span class="blob b1"></span><span class="blob b2"></span><span class="blob b3"></span></div>
  <div class="wm" id="wm"></div>
  <div class="container">
    <div class="topbar">
      <div class="toggle">
        <button class="icon-btn" id="themeBtn" title="Ø§Ù„Ù…Ø¸Ù‡Ø±">ğŸŒ™</button>
        <button class="icon-btn" id="langBtn" title="Ø§Ù„Ù„ØºØ©">AR/EN</button>
        <button class="icon-btn" id="guideBtn" title="Ø§Ù„Ø¯Ù„ÙŠÙ„">ğŸ“˜</button>
      </div>
      <div style="flex:1"></div>
      <div class="segmented" id="modeSeg">
        <button class="seg-btn active" data-mode="solve">Ø§Ø­Ø³Ø¨ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©</button>
        <button class="seg-btn" data-mode="steps">Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·ÙˆØ§Øª</button>
        <button class="seg-btn" data-mode="game">ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨</button>
        <button class="seg-btn" data-mode="calc">ØªÙØ§Ø¶Ù„/ØªÙƒØ§Ù…Ù„</button>
      </div>
    </div>
    <div class="glass-card">
      <h1 id="title">ğŸ§® Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø§ÙƒÙ„ÙˆØ±ÙŠÙ†</h1>
      <div class="muted" id="desc">Ø±ÙƒØ² ÙÙ‚Ø· Ø¹Ù„Ù‰ sinØŒ cosØŒ tan Ø¹Ù†Ø¯Ù…Ø§ x â†’ a</div>
    </div>
    <br />
    <div class="glass-card">
      <div class="row">
        <div>
          <label id="exprLabel">Ø§Ù„ØªØ¹Ø¨ÙŠØ± (ÙÙ‚Ø· sin, cos, tan Ùˆ Ø§Ù„Ù…ØªØºÙŠØ± x)</label>
          <div id="exprFieldContainer" class="mathfield-container">
            <input id="exprText" value="tan(x)/x" class="textfield" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙƒÙ†Øµ (ÙŠØ¯Ø¹Ù… Ù„Ø§ØªÙƒØ³)" />
            <math-field id="exprMath" class="mathfield" virtual-keyboard-mode="manual" smart-fence style="display:none" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø§Ù„Ù„Ø§ØªÙƒØ³ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±"></math-field>
          </div>
          <div class="muted" id="examples">Ø£Ù…Ø«Ù„Ø©: sin(x)/x ØŒ tan(x)/x ØŒ (1-cos(x))/x**2</div>
          <div class="muted" id="renderNote" style="margin-top:6px;">ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</div>
          <div id="questionDisplay" class="glass-card center" style="display:none; margin-top:8px;"></div>
          
        </div>
        <div id="ansBlock">
          <label id="ansLabel">Ø§Ù„Ù†Øµ</label>
          <div id="hintMini" class="muted" style="display:none; margin:6px 0 8px 0;"></div>
          <div class="ans-menu" id="ansMenu">
            <button id="ansMenuBtn" class="ans-menu-btn" aria-label="menu">â‰¡</button>
            <div id="ansMenuTip" class="ans-menu-tip"></div>
          </div>
          <div id="ansHelp" class="muted" style="margin:4px 0 6px 0;">ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒØ³ÙˆØ± Ù…Ù† Ù‡Ù†Ø§</div>
          <div id="math-field-container" class="mathfield-container">
            <input id="ansText" class="textfield" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙƒÙ†Øµ (ÙŠØ¯Ø¹Ù… Ù„Ø§ØªÙƒØ³)" />
            <math-field id="ansMath" class="mathfield" virtual-keyboard-mode="manual" smart-fence style="display:none" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ù„Ù„Ø§ØªÙƒØ³ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±"></math-field>
            <button id="kbClose" class="kb-close-btn" aria-label="close">âœ•</button>
          </div>
          <div class="keypad" id="ansPad">
            <button class="mini-btn" data-ins="frac" title="Ø¥Ø¯Ø±Ø§Ø¬ ÙƒØ³Ø±">ÙƒØ³Ø±</button>
            <button class="mini-btn" data-ins="pow" title="Ø¥Ø¯Ø±Ø§Ø¬ Ø£Ø³">Ø£Ø³</button>
            <button class="mini-btn" data-ins="sqrt" title="Ø¥Ø¯Ø±Ø§Ø¬ Ø¬Ø°Ø±">Ø¬Ø°Ø± âˆš</button>
            <button class="mini-btn" data-ins="pi" title="pi">Ï€</button>
            <button class="mini-btn" data-ins="sin" title="sin">sin</button>
            <button class="mini-btn" data-ins="cos" title="cos">cos</button>
            <button class="mini-btn" data-ins="tan" title="tan">tan</button>
            <button class="mini-btn" data-ins="parens" title="Ø£Ù‚ÙˆØ§Ø³">( )</button>
          </div>
        </div>
      </div>
      <!-- Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨: Ø¥Ø¯Ø®Ø§Ù„ Ø±ÙŠØ§Ø¶ÙŠ/Ù†ØµÙŠ -->
      <div class="control" style="margin-top:10px; gap:10px; align-items:center; flex-wrap:wrap;">
        <label id="pointLabel">Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨</label>
        <div id="point-field-container" class="mathfield-container" style="flex:1 1 100%;">
          <input id="pointText" class="textfield" placeholder="Ø£Ø¯Ø®Ù„ Ù‚ÙŠÙ…Ø© a (Ù…Ø«Ù„ Ï€/4 Ø£Ùˆ 0)" style="display:none" />
          <math-field id="pointMath" class="mathfield" virtual-keyboard-mode="manual" smart-fence placeholder="Ø§ÙƒØªØ¨ Ù‚ÙŠÙ…Ø© a Ù…Ø«Ù„ \pi/4 Ø£Ùˆ 0"></math-field>
        </div>
        <div id="approachHUD" class="muted" style="margin-top:6px; font-size:1rem;"></div>
      </div>
      <div id="orderRow" class="control" style="display:none; margin-top:10px;">
        <label id="orderLabel">Ø±ØªØ¨Ø© Ø§Ù„Ø³Ù„Ø³Ù„Ø©</label>
        <input id="order" type="range" min="3" max="11" step="2" value="7" />
        <span class="muted" id="orderVal">n=7</span>
      </div>
      <div id="gameToolbar" class="control" style="display:none; margin-top:10px; gap:8px; flex-wrap:wrap;">
        <div class="segmented" id="diffSeg" style="flex:1 1 auto; justify-content:flex-start;">
          <button class="seg-btn active" data-diff="easy">Ø³Ù‡Ù„</button>
          <button class="seg-btn" data-diff="med">Ù…ØªÙˆØ³Ø·</button>
          <button class="seg-btn" data-diff="hard">ØµØ¹Ø¨</button>
        </div>
        <button class="btn-outline" id="newQ" style="flex:0 0 auto;">ğŸ² Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯</button>
        <button class="btn-outline" id="hintBtn" style="flex:0 0 auto;">ğŸ’¡ ØªÙ„Ù…ÙŠØ­</button>
      </div>
      <!-- Ù…ÙƒØ§Ù† Ø«Ø§Ø¨Øª Ù„ÙˆØ¶Ø¹ Ø®Ø§Ù†Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØªØ­Øª Ø²Ø± Ø§Ù„ØªÙ„Ù…ÙŠØ­ ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ -->
      <div id="ansContainer" style="display:none; margin-top:8px;"></div>
      <!-- Training read-only graph appears above the Check button when in game mode -->
      <div id="trainGraph" class="fade-in" style="display:none; margin-top:8px;"></div>
      <br />
      <button id="check">ØªØ­Ù‚Ù‚</button>
    </div>
    <br />
    <div id="hint" class="glass-card" style="display:none;"></div>
    <br />
    <div id="result" class="glass-card center"></div>
    <br />
    <div id="hud" class="glass-card" style="display:none;">
      <div class="scorebar">
        <div class="score" id="scoreLabel">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</div>
        <div class="bar"><span id="progressFill"></span></div>
        <button class="btn-outline" id="resetScore">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†</button>
      </div>
      <div class="muted" style="margin-top:8px; display:flex; gap:14px; flex-wrap:wrap;">
        <span id="streakLabel">Ø³Ù„Ø³Ù„Ø© ØµØ­ÙŠØ­Ø©: 0ğŸ”¥</span>
        <span id="accLabel">Ø§Ù„Ø¯Ù‚Ø©: 0%</span>
      </div>
    </div>
    <br />
    <!-- Ø³ÙŠØªÙ… Ù†Ù‚Ù„ Ø§Ù„Ø¯Ù„ÙŠÙ„ Ù„Ø£Ø³ÙÙ„ Ø§Ù„ØµÙØ­Ø© -->

    <!-- Ø¨Ø·Ø§Ù‚Ø© ÙˆØ¶Ø¹ Ø§Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø³ØªÙ‚Ù„ -->
    <div id="calcCard" class="glass-card" style="display:none; margin-top:16px;">
      <h3>ğŸ” Ø§Ù„ØªÙØ§Ø¶Ù„ ÙˆØ§Ù„ØªÙƒØ§Ù…Ù„</h3>
      <div class="row" style="gap:12px; align-items:center; flex-wrap:wrap;">
        <div class="seg" id="calcModeSeg">
          <button class="seg-btn active" data-calc="diff">ØªÙØ§Ø¶Ù„</button>
          <button class="seg-btn" data-calc="int">ØªÙƒØ§Ù…Ù„</button>
        </div>
        <div class="spacer"></div>
        <div class="seg" id="calcQualitySeg" title="Ø§Ù„Ø¯Ù‚Ø© (Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø·)">
          <button class="seg-btn active" data-q="normal">Ø¹Ø§Ø¯ÙŠØ©</button>
          <button class="seg-btn" data-q="high">Ø¹Ø§Ù„ÙŠØ©</button>
        </div>
        <span id="calcQualityHint" class="muted" style="font-size:.9rem;">Ø¹Ø§Ø¯ÙŠØ©: Ø£Ø³Ø±Ø¹ â€¢ Ø¹Ø§Ù„ÙŠØ©: ÙˆØ¶ÙˆØ­ ÙˆØ¯Ù‚Ù‘Ø© Ø£Ø¹Ù„Ù‰</span>
      </div>
      <div class="row" style="margin-top:8px; gap:10px; align-items:flex-end; flex-wrap:wrap;">
        <div style="flex:2 1 360px;">
          <label class="muted">Ø§Ù„ØªØ¹Ø¨ÙŠØ± f(x)</label>
          <math-field id="calcMath" style="width:100%;"></math-field>
          <input id="calcText" type="text" class="input" style="width:100%; display:none;" placeholder="Ù…Ø«Ø§Ù„: sin(x)/x Ø£Ùˆ (x^2+1)" />
        </div>
        <div id="calcAtRow" style="flex:1 1 200px;">
          <label class="muted">Ø¹Ù†Ø¯ x = a (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
          <input id="calcAt" type="text" class="input" placeholder="Ù…Ø«Ø§Ù„: 0 Ø£Ùˆ pi/4" />
        </div>
        
        <div>
          <button id="calcRun" class="btn primary">ØªØ­Ù‚Ù‘Ù‚</button>
        </div>
      </div>
      <div id="calcResult" class="glass-card" style="margin-top:10px;"></div>
      <div id="calcGraph" style="width:100%; height:320px; margin-top:10px;"></div>
    </div>
    <br />
    <!-- Ø§Ù„Ø¯Ù„ÙŠÙ„ ÙÙŠ Ø£Ø³ÙÙ„ Ø§Ù„ØµÙØ­Ø© ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª -->
    <div id="guide" class="glass-card" style="white-space:pre-wrap"></div>
  </div>

  <!-- ÙŠÙØ¶Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù… mp3ØŒ Ù…Ø¹ Ø¨Ø¯ÙŠÙ„ wav Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙˆÙØ± -->
  <audio id="applause" preload="auto">
    <source src="audio/clap.mp3" type="audio/mpeg" />
    <source src="audio/applause.wav" type="audio/wav" />
  </audio>
  <div class="overlay" id="overlay"></div>
  <!-- Mobile keyboard dismiss button removed as requested -->
  

  <script>
    const LIGHT = { '--bg':'#f6f8ff','--text':'#0f172a','--muted':'#475569','--accent':'#5b7cff','--glass-bg':'rgba(255,255,255,0.75)','--glass-border':'rgba(15, 23, 42, 0.08)','--wm-color':'rgba(15, 23, 42, 0.05)' };
    const DARK  = { '--bg':'#0b1220','--text':'#e5e7eb','--muted':'#94a3b8','--accent':'#a78bfa','--glass-bg':'rgba(17,24,39,0.45)','--glass-border':'rgba(148,163,184,0.4)','--wm-color':'rgba(229, 231, 235, 0.06)' };
    let theme = 'dark';
    let lang = 'ar';
    let mode = 'solve';
    // initialize approach point early to avoid TDZ errors in applyLang()
    let pointSel = '0';
    let lastValue = null;
    let kbTarget = null; // 'ans' or 'expr' to route keyboard ownership
    let reactionList = [];
    let reactionMessages = null; // Ø±Ø³Ø§Ø¦Ù„ Ø§Ø®ØªÙŠØ§Ø±ÙŠØ© ØªÙØ­Ù…Ù‘ÙÙ„ Ù…Ù† Ù…Ù„Ù reactions/messages.json
    let audioCtx = null, applauseBuffer = null;
    // Ù…Ø±Ø¬Ø¹ Ù„Ù…ÙˆØ¶Ø¹ Ø®Ø§Ù†Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø£ØµÙ„ÙŠ
    let ansOrigParent = null, ansAnchor = null;
    // ØªØ¹Ø§Ø±ÙŠÙ Ù…Ø¨ÙƒØ±Ø© Ù„Ù‚ÙŠÙ… HUD Ù„Ø¶Ù…Ø§Ù† ØªÙˆÙØ±Ù‡Ø§ Ù‚Ø¨Ù„ Ø£ÙŠ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡
    let score = 0, attempts = [], streak = 0, correct = 0, total = 0;
    // ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„: bounds Ù…Ø³ØªØ®Ø±Ø¬Ø© Ù…Ù† ØµÙŠØºØ© \int ÙÙŠ Ø§Ù„Ù„Ø§ØªÙƒØ³ Ø¥Ù† ÙƒØªØ¨Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¨Ø§Ø´Ø±Ø©
    let calcLatexBounds = null;
    const REACTION_MSG_DEFAULT = {
      ar: {
        '1': 'Ù…Ø³ØªØ­ÙŠÙ„ Ø­Ù„Ùƒ ÙƒØ°Ø§ !!',
        '2': 'Ù…Ø¯Ø±ÙŠ Ø´Ù‚ÙˆÙ„ Ø§Ù„ØµØ±Ø§Ø­Ù‡',
        '3': 'Ø§Ù„ÙˆØ§Ø¶Ø­ Ù…Ø§ Ø¨Ø±Ø§Ø³Ùƒ Ø¹Ù„Ù…',
        '4': 'Ø­Ø§ÙˆÙ„ ØªÙÙƒØ± Ø°Ø§ Ø­Ù„ Ø§Ù†Ø³Ø§Ù† ØŸ',
        '5': 'Ù‡Ø°Ø§ Ø§Ù†Øª ÙˆÙ†Øª ØªÙ‚ÙˆÙ„ Ø¨Ø°Ø§ÙƒØ± ÙˆÙ†Øª ÙƒØ°Ø§Ø¨',
        '6': 'Ù„Ùˆ Ø§Ù„Ø­Ù„ Ø§Ù„Ø¬Ø§ÙŠ Ø®Ø·Ø§Ø¡ Ø¨ØªÙ†Ø¬Ù„Ø¯',
        '7': 'Ù…ØªØ£ÙƒØ¯ Ø§Ù†Øª Ø¯Ø§Ø±Ø³',
        '8': 'ÙŠØ§Ø®ÙŠ Ø§Ù†Øª ÙƒÙŠÙ ÙƒØ°Ø§ØŸ',
        '9': 'ÙƒØ°Ø§ ÙƒØ«ÙŠØ± !!',
        '10': '',
        '11': 'ØªÙÙƒØ± Ùˆ ØªÙÙƒØ± Ùˆ ØªÙÙƒØ± ÙˆØ§Ø®Ø± Ø´ÙŠ Ø°Ø§ Ø­Ù„Ùƒ !',
        '12': '', '13': '', '14': '', '15': '', '16': '', '17': '',
        '18': 'Ø§Ù„ÙŠ ÙŠØ¨ÙŠ Ø§Ù„Ø¹Ø² Ù„Ø§ÙŠÙ†Ø´Ø¯ Ø¹Ù† Ø§Ù„Ø±Ø§Ø­Ù‡ Ù†ÙŠØ±Ø§Ù† Ø§Ù„Ø§Ù…Ø¬Ø§Ø¯ ØªØ¨ÙŠ Ù…Ù† ÙŠØµØ§Ù„ÙŠÙ‡Ø§'
      },
      en: {
        '1': 'No way thatâ€™s correct!!',
        '2': 'Honestlyâ€¦ Iâ€™ve got no words.',
        '3': 'Clearly needs more study',
        '4': 'Think it through like a human?',
        '5': "This is you saying you'll study, but lying.",
        '6': 'Better get the next one right.',
        '7': 'Are you sure you studied?',
        '8': 'How did you even do that?',
        '9': 'Thatâ€™s a bit much!',
        '10': '',
        '11': 'You think and thinkâ€¦ and thatâ€™s your answer!',
        '12': '', '13': '', '14': '', '15': '', '16': '', '17': '',
        '18': 'Ø§Ù„ÙŠ ÙŠØ¨ÙŠ Ø§Ù„Ø¹Ø² Ù„Ø§ÙŠÙ†Ø´Ø¯ Ø¹Ù† Ø§Ù„Ø±Ø§Ø­Ù‡ Ù†ÙŠØ±Ø§Ù† Ø§Ù„Ø§Ù…Ø¬Ø§Ø¯ ØªØ¨ÙŠ Ù…Ù† ÙŠØµØ§Ù„ÙŠÙ‡Ø§'
      }
    };

    // Success reaction image + default phrase
    const SUCCESS_REACTION_NAME = 'reaction101.jpg';
    const SUCCESS_MSG_DEFAULT = {
      ar: 'Ø¹Ù†Ø¯Ùƒ Ø¬ÙŠÙ†Ø§Øª Ø§ÙŠÙ†Ø´ØªØ§ÙŠÙ†',
      en: "You've got Einstein genes"
    };

    const STR = {
      ar: {
        title: 'ğŸ§® Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø§ÙƒÙ„ÙˆØ±ÙŠÙ†',
        descBase: 'Ø±ÙƒØ² ÙÙ‚Ø· Ø¹Ù„Ù‰ sin , cos , tan Ø¹Ù†Ø¯Ù…Ø§ x â†’ {a}',
        descTag: '(Ø§Ù„ØªÙØ§Ø¶Ù„ ÙˆØ§Ù„ØªÙƒØ§Ù…Ù„)',
        pointLabel: 'Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨',
        limitAs: 'Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¹Ù†Ø¯ xâ†’',
        exprLabel: 'Ø§Ù„ØªØ¹Ø¨ÙŠØ± (ÙÙ‚Ø· sin Ùˆcos Ùˆtan ÙˆØ§Ù„Ù…ØªØºÙŠØ± x)',
        examples: 'Ø£Ù…Ø«Ù„Ø©: sin(x)/x ØŒ tan(x)/x ØŒ (1-cos(x))/x**2',
        renderNote: 'ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§',
        exprPlaceholderText: 'Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙƒÙ†Øµ (ÙŠØ¯Ø¹Ù… Ù„Ø§ØªÙƒØ³)',
        exprPlaceholderMath: 'Ø£Ø¯Ø®Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø§Ù„Ù„Ø§ØªÙƒØ³ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±',
        ansLabel: 'Ø§Ù„Ù†Øµ',
        check: 'ØªØ­Ù‚Ù‚',
        orderLabel: 'Ø±ØªØ¨Ø© Ø§Ù„Ø³Ù„Ø³Ù„Ø©',
        orderVal: (n)=>`n=${n}`,
        solve: 'Ø§Ø­Ø³Ø¨ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©', steps: 'Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·ÙˆØ§Øª', game: 'ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨', graph: 'Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ',
        invalid: 'Ø¥Ø¯Ø®Ø§Ù„ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø³ØªØ®Ø¯Ù… ÙÙ‚Ø· sin Ùˆcos Ùˆtan ÙˆØ§Ù„Ù…ØªØºÙŠØ± x.',
        success: 'Ø¹Ù…Ù„ Ø±Ø§Ø¦Ø¹! Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©', fail: 'Ù„ÙŠØ³Øª ØµØ­ÙŠØ­Ø© â€” Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰',
        copy: 'ğŸ“‹ Ù†Ø³Ø®',
        points: (n)=>`Ø§Ù„Ù†Ù‚Ø§Ø·: ${n}`,
        reset: 'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†',
        menuTip: 'Ù„Ø¥Ø¶Ø§ÙØ© Ø®ØµØ§Ø¦Øµ Ø£ÙƒØ«Ø± Ù…Ø«Ù„ Ø§Ù„Ù…ØµÙÙˆÙØ© ÙˆØºÙŠØ±Ù‡Ø§ â€” Ù…Ù† Ù‡Ù†Ø§',
        ansHelp: 'ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒØ³ÙˆØ± Ù…Ù† Ù‡Ù†Ø§',
        ansPlaceholder: 'Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ù„Ù„Ø§ØªÙƒØ³ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±',
        diff: { easy: 'Ø³Ù‡Ù„', med: 'Ù…ØªÙˆØ³Ø·', hard: 'ØµØ¹Ø¨' },
        newQ: 'ğŸ² Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯',
        hintBtn: 'ğŸ’¡ ØªÙ„Ù…ÙŠØ­',
        keypad: { frac: 'ÙƒØ³Ø±', pow: 'Ø£Ø³', sqrt: 'Ø¬Ø°Ø± âˆš' },
        guide: `ğŸ“˜ Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ\n\nÙ…Ù„Ø§Ø­Ø¸Ø©: Ø¥Ù† Ø¸Ù‡Ø± Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø±Ù…ÙˆØ² Ø±ÙŠØ§Ø¶ÙŠØ© (Ù…Ø«Ù„ \dfracØŒ Ø§Ù„Ø£Ø³ØŒ Ø§Ù„Ø¬Ø°Ø±)ØŒ ÙÙ‡Ø°Ø§ Ø¹Ø±Ø¶ÙŒ Ù„ØªÙˆØ¶ÙŠØ­ Ø§Ù„Ø´ÙƒÙ„. Ø§ÙƒØªØ¨ Ø£Ùˆ Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙÙŠ Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ø¹Ù„ÙˆÙŠØŒ ÙˆÙŠÙ…ÙƒÙ†Ùƒ ÙØªØ­ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©.\n\n- Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù„Ø§ØªÙŠÙ†ÙŠØ©: sin, cos, tan ÙˆØ§Ù„Ù…ØªØºÙŠØ± x Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù‚Ù„.\n- Ø²Ø± "ÙƒØ³Ø±" ÙŠÙØ¯Ø®Ù„ Ù‚Ø§Ù„Ø¨ ÙƒØ³Ø± Ø­Ù‚ÙŠÙ‚ÙŠ: ÙŠØ¸Ù‡Ø± Ù…Ø±Ø¨Ø¹Ø§Ù† Ù„Ù„Ø¨Ø³Ø· ÙˆØ§Ù„Ù…Ù‚Ø§Ù….\n  â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø³Ù‡Ù… Ø£Ùˆ Tab Ù„Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª.\n- Ø§Ù„Ù‚Ø³Ù…Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©: a/b â€” ÙˆØ§Ù„Ø£Ø³: a^{n} Ø£Ùˆ Ø²Ø± "Ø£Ø³" \n Ù…Ø¹ Ø§Ù„Ø¹Ù„Ù… Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø§Ø³ Ù‡ÙŠ *.\n- Ø§Ù„Ø¬Ø°Ø±: Ø²Ø± "Ø¬Ø°Ø± âˆš" â€” Ùˆ Ï€: Ø²Ø± "Ï€".\n- Ø§Ù„Ø£Ù‚ÙˆØ§Ø³: Ø²Ø± "( )" Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø£Ù‚ÙˆØ§Ø³ Ø¬Ø§Ù‡Ø²Ø©.\n- Ø£Ù…Ø«Ù„Ø© Ø³Ø±ÙŠØ¹Ø©:\n  â€¢ sin(x)/x\n  â€¢ (1 - cos(2*x)) / x**2\n  â€¢ \\frac{1 - \\cos(2x)}{x^2}\n- Ø¨Ø¹Ø¯ Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„ÙƒØ³Ø± ÙŠÙ†ØªÙ‚Ù„ Ø§Ù„Ù…Ø¤Ø´Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¥Ù„Ù‰ Ø§Ù„Ø¨Ø³Ø· Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„ÙƒØªØ§Ø¨Ø©.\n- ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨: Ø§Ø³ØªØ®Ø¯Ù… "ğŸ² Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯" Ùˆ"ğŸ’¡ ØªÙ„Ù…ÙŠØ­" Ù„Ø¹Ø±Ø¶ ØªÙˆØ³Ø¹Ø§Øª Ù…Ø§ÙƒÙ„ÙˆØ±ÙŠÙ†ØŒ ÙˆØ±Ø§Ù‚Ø¨ Ø§Ù„Ø¯Ù‚Ø© ÙˆØ§Ù„Ø³Ù„Ø³Ù„Ø© ÙÙŠ HUD.`
      },
      en: {
        title: 'ğŸ§® Trig Limits via Maclaurin',
        descBase: 'Focus only on sin, cos, tan as x â†’ {a}',
        descTag: '(Calculus)',
        pointLabel: 'Approach point',
        limitAs: 'Limit as xâ†’',
        exprLabel: 'Expression (only sin, cos, tan with x)',
        examples: 'Examples: sin(x)/x, tan(x)/x, (1-cos(x))/x**2',
        renderNote: 'Question is rendered with math symbols automatically',
        exprPlaceholderText: 'Enter the question as text (LaTeX supported)',
        exprPlaceholderMath: 'Enter the question in LaTeX or use buttons',
        ansLabel: 'Text',
        check: 'Check',
        orderLabel: 'Series order',
        orderVal: (n)=>`n=${n}`,
        solve: 'Quick Solve', steps: 'Step-by-Step', game: 'Training Mode', graph: 'Interactive Graphing',
        invalid: 'Invalid input. Use only sin, cos, tan and variable x.',
        success: 'Great job! Correct answer', fail: 'Not correct â€” try again',
        copy: 'ğŸ“‹ Copy',
        points: (n)=>`Points: ${n}`,
        reset: 'Reset',
        menuTip: 'For more features like matrices, open this menu',
        ansHelp: 'You can insert fractions here',
        ansPlaceholder: 'Enter the answer in LaTeX or use buttons',
        diff: { easy: 'Easy', med: 'Medium', hard: 'Hard' },
        newQ: 'ğŸ² New Question',
        hintBtn: 'ğŸ’¡ Hint',
        keypad: { frac: 'Frac', pow: 'Pow', sqrt: 'âˆš' },
        guide: `ğŸ“˜ Guide\n\nNote: If the question appears with mathematical symbols (like \\dfrac, powers, sqrt), thatâ€™s just visual rendering. Enter or edit the question in the top field and open the math keyboard from the menu.\n\n- Use sin(x), cos(x), tan(x); power with **; pi for Ï€; add parentheses for complex operations.`
      }
    };

    function applyTheme() {
      const vars = theme === 'light' ? LIGHT : DARK;
      for (const k in vars) document.documentElement.style.setProperty(k, vars[k]);
      document.getElementById('themeBtn').textContent = theme === 'light' ? 'ğŸŒ™' : 'â˜€ï¸';
      // ØªØ­Ø¯ÙŠØ« ØªÙ…ÙˆØ¶Ø¹/Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ù…Ø§Ø¦ÙŠØ© Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø«ÙŠÙ…
      populateWatermark();
    }

    function applyLang() {
      const s = STR[lang];
      document.documentElement.setAttribute('lang', lang === 'ar' ? 'ar' : 'en');
      document.documentElement.setAttribute('dir', lang === 'ar' ? 'rtl' : 'ltr');
      document.getElementById('title').textContent = s.title;
      const descEl = document.getElementById('desc');
      if (descEl) {
        const base = (s.descBase||'').replace('{a}', pointSel||'a');
        const tag = s.descTag || '';
        descEl.innerHTML = `<span class="desc-tag">${tag}</span><span class="desc-base">${base}</span>`;
      }
      // Use LTR isolates for Latin tokens to avoid mixing like "cosg/tang"
      const exprLabel = (lang==='ar') ? 'Ø§Ù„ØªØ¹Ø¨ÙŠØ± (ÙÙ‚Ø· <span class="latin">sin, cos, tan</span> ÙˆØ§Ù„Ù…ØªØºÙŠØ± x)' : 'Expression (only <span class="latin">sin, cos, tan</span> with x)';
      document.getElementById('exprLabel').innerHTML = exprLabel;
      document.getElementById('examples').textContent = s.examples;
      const rn = document.getElementById('renderNote'); if (rn && s.renderNote) rn.textContent = s.renderNote;
      document.getElementById('ansLabel').textContent = s.ansLabel;
      document.getElementById('check').textContent = s.check;
      const seg = document.getElementById('modeSeg');
      const btns = seg.querySelectorAll('.seg-btn');
      if (btns[0]) btns[0].textContent = s.solve;
      if (btns[1]) btns[1].textContent = s.steps;
      if (btns[2]) btns[2].textContent = s.game;
      if (btns[3]) btns[3].textContent = (lang==='ar'? 'ØªÙØ§Ø¶Ù„/ØªÙƒØ§Ù…Ù„' : 'Calculus');
      // Graphing labels
      // ØªÙ…Øª Ø¥Ø²Ø§Ù„Ø© Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø±Ø³Ù… Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ
      document.getElementById('guide').textContent = s.guide;
      document.getElementById('orderLabel').textContent = s.orderLabel;
      const pointL = document.getElementById('pointLabel'); if (pointL && s.pointLabel) pointL.textContent = s.pointLabel;
      document.getElementById('orderVal').textContent = s.orderVal(parseInt(document.getElementById('order').value));
      // HUD labels
      const rs = document.getElementById('resetScore'); if (rs) rs.textContent = s.reset;
      const st = document.getElementById('streakLabel'); if (st) st.textContent = (lang==='ar'? `Ø³Ù„Ø³Ù„Ø© ØµØ­ÙŠØ­Ø©: ${streak}ğŸ”¥` : `Streak: ${streak}ğŸ”¥`);
      const ac = document.getElementById('accLabel'); if (ac) {
        const acc = total? Math.round((correct/total)*100) : 0;
        ac.textContent = (lang==='ar'? `Ø§Ù„Ø¯Ù‚Ø©: ${acc}%` : `Accuracy: ${acc}%`);
      }
      const ah = document.getElementById('ansHelp'); if (ah) ah.textContent = s.ansHelp;
      const mt = document.getElementById('ansMenuTip'); if (mt) mt.textContent = s.menuTip;
      const kb = document.getElementById('kbDismiss'); if (kb) kb.textContent = (lang==='ar'? 'ØªÙ…' : 'Done');
      // Placeholder for MathLive
      const mf = document.getElementById('ansMath'); if (mf && s.ansPlaceholder) mf.setAttribute('placeholder', s.ansPlaceholder);
      const tx = document.getElementById('ansText'); if (tx) tx.setAttribute('placeholder', (lang==='ar'? 'Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙƒÙ†Øµ (ÙŠØ¯Ø¹Ù… Ù„Ø§ØªÙƒØ³)' : 'Enter answer as text (LaTeX supported)'));
      // Expression field placeholders
      const em = document.getElementById('exprMath'); if (em && s.exprPlaceholderMath) em.setAttribute('placeholder', s.exprPlaceholderMath);
      const et = document.getElementById('exprText'); if (et && s.exprPlaceholderText) et.setAttribute('placeholder', s.exprPlaceholderText);
      // Approach point placeholders
      const pm = document.getElementById('pointMath'); if (pm) pm.setAttribute('placeholder', (lang==='ar'? 'Ø§ÙƒØªØ¨ Ù‚ÙŠÙ…Ø© a Ù…Ø«Ù„ \\pi/4 Ø£Ùˆ 0' : 'Enter a like \\pi/4 or 0'));
      const pt = document.getElementById('pointText'); if (pt) pt.setAttribute('placeholder', (lang==='ar'? 'Ø£Ø¯Ø®Ù„ Ù‚ÙŠÙ…Ø© a (Ù…Ø«Ù„ Ï€/4 Ø£Ùˆ 0)' : 'Enter value a (like pi/4 or 0)'));
      // Difficulty / training controls
      const dBtns = document.querySelectorAll('#diffSeg .seg-btn'); if (dBtns && dBtns.length===3 && s.diff) { dBtns[0].textContent = s.diff.easy; dBtns[1].textContent = s.diff.med; dBtns[2].textContent = s.diff.hard; }
      const newQB = document.getElementById('newQ'); if (newQB && s.newQ) newQB.textContent = s.newQ;
      const hintB = document.getElementById('hintBtn'); if (hintB && s.hintBtn) hintB.textContent = s.hintBtn;
      // Keypad labels
      if (s.keypad) {
        const bFrac = document.querySelector('#ansPad [data-ins="frac"]'); if (bFrac) bFrac.textContent = s.keypad.frac;
        const bPow = document.querySelector('#ansPad [data-ins="pow"]'); if (bPow) bPow.textContent = s.keypad.pow;
        const bSqrt = document.querySelector('#ansPad [data-ins="sqrt"]'); if (bSqrt) bSqrt.textContent = s.keypad.sqrt;
      }
    }
    function sanitizeExpr(expr) {
      // Allow only digits, x, sin cos tan, operators +-*/**(), spaces
      const ok = /^[\s0-9x+\-*/().]*$/.test(expr.replace(/sin|cos|tan/g, ''));
      if (!ok) return null;
      // Replace power operator if using ^ with **
      expr = expr.replace(/\^/g, '**');
      // Replace trig to Math.*
      expr = expr.replace(/sin\s*\(/g, 'Math.sin(')
                 .replace(/cos\s*\(/g, 'Math.cos(')
                 .replace(/tan\s*\(/g, 'Math.tan(');
      return expr;
    }

    // ØªØ¹Ø¨ÙŠØ±Ø§Øª ÙˆØ¶Ø¹ Ø§Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„: Ø¯Ø¹Ù… Ø¯ÙˆØ§Ù„ Ø£ÙˆØ³Ø¹
    function sanitizeCalcExpr(expr){
      // ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„Ø£Ø­Ø±Ù ÙˆØ§Ù„Ø£Ø±Ù‚Ø§Ù… Ùˆ x ÙˆØ§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ¯ÙˆØ§Ù„: sin cos tan exp log ln sqrt abs
      const ok = /^[\s0-9x+\-*/().,A-Za-z_]*$/.test(expr);
      if (!ok) return null;
      let s = expr;
      s = s.replace(/\^/g, '**');
      // map ln->log
      s = s.replace(/\bln\s*\(/g, 'Math.log(');
      s = s.replace(/\blog\s*\(/g, 'Math.log(');
      s = s.replace(/\bexp\s*\(/g, 'Math.exp(');
      s = s.replace(/\bsqrt\s*\(/g, 'Math.sqrt(');
      s = s.replace(/\babs\s*\(/g, 'Math.abs(');
      s = s.replace(/\bsin\s*\(/g, 'Math.sin(')
             .replace(/\bcos\s*\(/g, 'Math.cos(')
             .replace(/\btan\s*\(/g, 'Math.tan(');
      return s;
    }

    // Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ¶Ø¹ Ø§Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„
    function getCalcExpr(){
      const mf = document.getElementById('calcMath');
      const tf = document.getElementById('calcText');
      let v = '';
      calcLatexBounds = null;
      try {
        const mfVisible = mf && mf.style.display !== 'none';
        if (mfVisible && mf.getValue) v = String(mf.getValue('latex')||'');
        else v = String(tf ? tf.value||'' : '');
      } catch { v = String(tf ? tf.value||'' : ''); }
      v = String(v||'').trim();
      // Ø¥Ø°Ø§ ÙƒØªØ¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØªÙƒØ§Ù…Ù„Ù‹Ø§ ÙƒØ§Ù…Ù„Ø§Ù‹ Ø¨Ø§Ù„Ù€ LaTeX ÙØ­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¯Ø§Ù„Ø© ÙˆØ§Ù„Ø­Ø¯ÙˆØ¯
      if (/\\int/.test(v)) {
        try {
          const ex = extractIntegralFromLatex(v);
          if (ex && ex.expr) {
            if (Array.isArray(ex.bounds) && ex.bounds.length===2) calcLatexBounds = ex.bounds;
            return ex.expr;
          }
        } catch {}
      }
      if (/\\[A-Za-z]+/.test(v)) { try { v = latexToJSExprCached(v).replace(/Math\./g, ''); } catch {} }
      return v;
    }
    // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù†Øµ Ø§Ù„Ø®Ø§Ù… Ù…Ù† Ø­Ù‚Ù„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ø¨Ø¯ÙˆÙ† ØªØ­ÙˆÙŠÙ„
    function getCalcRaw(){
      try {
        const mf = document.getElementById('calcMath');
        if (mf && mf.style.display !== 'none' && mf.getValue) return String(mf.getValue('latex')||'');
      } catch {}
      try { const tf = document.getElementById('calcText'); return String(tf ? tf.value||'' : ''); } catch { return ''; }
    }
    function extractIntegralFromLatex(lx){
      try{
        let s = String(lx||'');
        s = s.replace(/\\,/g,' ').replace(/\\!/g,' ');
        const i = s.indexOf('\\int'); if (i<0) return null; let rest = s.slice(i+4).trim();
        let aTxt=null,bTxt=null;
        // lower bound: _{...} Ø£Ùˆ _a
        let mA = rest.match(/^_\{([^}]*)\}/);
        if (mA) { aTxt = mA[1]; rest = rest.slice(mA[0].length).trim(); }
        else { mA = rest.match(/^_([^\s\^]+)/); if (mA) { aTxt = mA[1]; rest = rest.slice(mA[0].length).trim(); } }
        // upper bound: ^{...} Ø£Ùˆ ^b
        let mB = rest.match(/^\^\{([^}]*)\}/);
        if (mB) { bTxt = mB[1]; rest = rest.slice(mB[0].length).trim(); }
        else { mB = rest.match(/^\^([^\s_]+)/); if (mB) { bTxt = mB[1]; rest = rest.slice(mB[0].length).trim(); } }
        // integrand up to dx (take last occurrence to be safer)
        // Ø£Ø²Ù„ \mathrm{dx} Ø¥Ù† ÙˆÙØ¬Ø¯Øª
        rest = rest.replace(/\\mathrm\s*\{\s*dx\s*\}/g, 'dx');
        let idx = rest.lastIndexOf('dx'); if (idx<0) idx = rest.lastIndexOf('d x');
        let integrand = (idx>0? rest.slice(0, idx): rest).trim();
        if (integrand.startsWith('(') && integrand.endsWith(')')) integrand = integrand.slice(1,-1).trim();
        let exprJS = latexToJSExprCached(integrand).replace(/Math\./g,'');
        // bounds numeric values
        let bounds=null; 
        if (aTxt!=null && bTxt!=null){
          const aVal = evalLatexNumeric(approachTextToLatex(aTxt));
          const bVal = evalLatexNumeric(approachTextToLatex(bTxt));
          if (Number.isFinite(aVal) && Number.isFinite(bVal)) bounds=[aVal,bVal];
        }
        return { expr: exprJS, bounds };
      }catch{ return null; }
    }
    function getCalcMode(){
      const seg = document.getElementById('calcModeSeg'); if (!seg) return 'diff';
      const a = seg.querySelector('.seg-btn.active');
      return a ? a.dataset.calc : 'diff';
    }
    function getCalcAt(){
      const t = document.getElementById('calcAt'); if (!t) return null;
      const s = String(t.value||'').trim(); if (!s) return null;
      const v = evalLatexNumeric(approachTextToLatex(s));
      return Number.isFinite(v)? v : null;
    }
    function getCalcBounds(){
      const a = document.getElementById('calcA'); const b = document.getElementById('calcB');
      if (!a || !b) return null;
      const sa = String(a.value||'').trim(); const sb = String(b.value||'').trim();
      if (!sa || !sb) return null;
      const va = evalLatexNumeric(approachTextToLatex(sa));
      const vb = evalLatexNumeric(approachTextToLatex(sb));
      if (!Number.isFinite(va) || !Number.isFinite(vb)) return null;
      return [va, vb];
    }

    async function handleCalcRun(){
      const out = document.getElementById('calcResult'); if (out) out.innerHTML = '';
      try {
        const expr = getCalcExpr();
        const raw = getCalcRaw();
        const safe = sanitizeCalcExpr(expr);
        if (!safe) { if (out) out.innerHTML = `<p class='muted'>Ø¥Ø¯Ø®Ø§Ù„ ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„</p>`; return; }
        const cm = getCalcMode();
        if (cm === 'diff'){
          const at = getCalcAt();
          let latexD = '';
          let valNum = null;
          if (pyodideReady){
            try {
              const r = await window.pyodide.runPythonAsync(`solve_calc(${JSON.stringify(raw)}, 'diff', ${Number.isFinite(at)? at : 'None'})`);
              const obj = (typeof r==='string')? JSON.parse(r): r;
              if (obj && obj.D_latex) latexD = obj.D_latex;
              if (obj && typeof obj.D_val === 'number' && Number.isFinite(obj.D_val)) valNum = obj.D_val;
            } catch{}
            if (!latexD) { try { latexD = await window.pyodide.runPythonAsync(`diff_latex(${JSON.stringify(expr)})`); } catch{} }
          }
          if (valNum == null && Number.isFinite(at)){
            try {
              let v = NaN;
              if (pyodideReady) { v = await window.pyodide.runPythonAsync(`deriv_slope(${JSON.stringify(expr)}, ${at})`); }
              if (!Number.isFinite(v)) {
                const f = compileCalcExprFn(expr);
                const h = 1e-5;
                v = (f(at+h)-f(at-h))/(2*h);
              }
              if (Number.isFinite(v)) valNum = v;
            } catch{}
          }
          const latexHtml = latexD? `<div>\\(\\dfrac{d}{dx}[f(x)] = ${latexD}\\)</div>` : '';
          const valStr = (Number.isFinite(at) && Number.isFinite(valNum)) ? (lang==='ar'? `ÙˆÙ‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø´ØªÙ‚Ø© Ø¹Ù†Ø¯ x=${at} Ù‡ÙŠ ${(+valNum).toFixed(6)}` : `Derivative at x=${at} is ${(+valNum).toFixed(6)}`) : '';
          if (out) {
            out.innerHTML = `<div class='row' style='justify-content:space-between; align-items:center;'>${latexHtml}<button id="calcCopy" class="btn-outline" style="font-size:.9rem; padding:.25rem .6rem;">Ù†Ø³Ø® Ø§Ù„Ù‚ÙŠÙ…Ø©</button></div><div class='muted'>${valStr}</div>`;
            try { const btn = out.querySelector('#calcCopy'); if (btn && Number.isFinite(valNum)) btn.setAttribute('data-val', String(valNum)); } catch{}
            if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
          }
          await renderCalcGraph(expr, { mode:'diff', at });
        } else {
          let F_latex = '';
          let bounds = null;
          let intVal = null;
          if (pyodideReady){
            try {
              const r = await window.pyodide.runPythonAsync(`solve_calc(${JSON.stringify(raw)}, 'int', None)`);
              const obj = (typeof r==='string')? JSON.parse(r): r;
              if (obj) {
                F_latex = obj.F_latex || F_latex;
                if (Array.isArray(obj.bounds)) bounds = obj.bounds;
                if (typeof obj.int_val === 'number' && Number.isFinite(obj.int_val)) intVal = obj.int_val;
              }
            } catch{}
            if (!F_latex) { try { F_latex = await window.pyodide.runPythonAsync(`integral_latex(${JSON.stringify(expr)})`); } catch{} }
          }
          if (!bounds) bounds = (calcLatexBounds && calcLatexBounds.length===2) ? calcLatexBounds : null;
          if (bounds){
            if (intVal == null) {
              try {
                if (pyodideReady){
                  const v = await window.pyodide.runPythonAsync(`integral_def_value(${JSON.stringify(expr)}, ${bounds[0]}, ${bounds[1]})`);
                  if (Number.isFinite(v)) intVal = v;
                }
              } catch{}
              if (intVal == null){
                try {
                  const f = compileCalcExprFn(expr);
                  const a = bounds[0], b = bounds[1];
                  if (a === b) intVal = 0; else {
                    const n = 2048; const h = (b-a)/n; let sum = 0;
                    let y0 = f(a), yN = f(b);
                    for (let i=1;i<n;i++){ const x=a+i*h; const y=f(x); sum += (i%2===0? 2*y : 4*y); }
                    let val = (h/3)*(y0 + yN + sum);
                    if (!Number.isFinite(val)) {
                      sum = 0; for (let i=1;i<n;i++){ sum += f(a+i*h); }
                      val = h*((y0+yN)/2 + sum);
                    }
                    if (Number.isFinite(val)) intVal = val;
                  }
                } catch{}
              }
            }
          }
          const latexHtml = F_latex? `<div>\\(F(x) = ${F_latex}\\)</div>` : '';
          const areaStr = (bounds && Number.isFinite(intVal)) ? (lang==='ar'? `Ù‚ÙŠÙ…Ø© Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ù† ${bounds[0]} Ø¥Ù„Ù‰ ${bounds[1]} â‰ˆ ${(+intVal).toFixed(6)}` : `âˆ« from ${bounds[0]} to ${bounds[1]} â‰ˆ ${(+intVal).toFixed(6)}`) : '';
          if (out) {
            out.innerHTML = `<div class='row' style='justify-content:space-between; align-items:center;'>${latexHtml}<button id="calcCopy" class="btn-outline" style="font-size:.9rem; padding:.25rem .6rem;">Ù†Ø³Ø® Ø§Ù„Ù‚ÙŠÙ…Ø©</button></div><div class='muted'>${areaStr}</div>`;
            try { const btn = out.querySelector('#calcCopy'); if (btn && Number.isFinite(intVal)) btn.setAttribute('data-val', String(intVal)); } catch{}
            if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
          }
          await renderCalcGraph(expr, { mode:'int', bounds });
        }
      } catch(err){ if (out) out.innerHTML = `<p class='muted'>Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨</p>`; }
    }

    function getCalcQuality(){
      const seg = document.getElementById('calcQualitySeg'); if (!seg) return 'normal';
      const b = seg.querySelector('.seg-btn.active'); return b? (b.dataset.q||'normal'):'normal';
    }

    async function renderCalcGraph(expr, opts){
      const target = document.getElementById('calcGraph'); if (!target) return;
      const isMobile = window.innerWidth <= 640;
      // Ù†Ø·Ø§Ù‚ x: Ø§Ø¬Ø¹Ù„Ù‡ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§ Ù„Ø§Ø­ØªÙˆØ§Ø¡ [a,b] Ø£Ùˆ Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù…Ø§Ø³
      const R = 2.0; let xmin=-R, xmax=R;
      try {
        if (opts && opts.mode==='int' && opts.bounds && Number.isFinite(opts.bounds[0]) && Number.isFinite(opts.bounds[1])){
          const a0 = Math.min(opts.bounds[0], opts.bounds[1]);
          const b0 = Math.max(opts.bounds[0], opts.bounds[1]);
          const span = Math.max(1e-6, Math.abs(b0 - a0));
          const pad = Math.max(0.5, span * 0.1);
          xmin = a0 - pad; xmax = b0 + pad;
        } else if (opts && opts.mode==='diff' && Number.isFinite(opts.at)) {
          const at = opts.at;
          if (at < xmin || at > xmax) { xmin = at - R; xmax = at + R; }
        }
      } catch{}
      let f; try { f = compileCalcExprFn(expr); } catch { f=null; }
      const q = getCalcQuality();
      const baseN = (q==='high') ? (isMobile? 560 : 1000) : (isMobile? 420 : 760);
      const N = baseN;
      const xs = new Array(N), ys=new Array(N);
      let yMin=Infinity, yMax=-Infinity;
      const addExt=(arr)=>{ for(const v of arr){ if(Number.isFinite(v)){ yMin=Math.min(yMin,v); yMax=Math.max(yMax,v);} } };
      for(let i=0;i<N;i++){ const x = xmin + (i*(xmax-xmin))/(N-1); xs[i]=x; try{ ys[i]= f?f(x):evalCalcAt(expr,x);} catch{ ys[i]=NaN; } }
      addExt(ys);
      const data=[ { x:xs, y:ys, mode:'lines', name:(lang==='ar'?'Ø§Ù„Ø¯Ø§Ù„Ø©':'Function'), line:{ color:'#5b7cff', width:2.6 } } ];
      const shapes=[]; const annotations=[];
      if (opts && opts.mode==='diff' && opts.at!=null){
        let m=NaN, y0=NaN; try{ y0 = f?f(opts.at):evalCalcAt(expr, opts.at);} catch{}
        try{ if(pyodideReady) m = await window.pyodide.runPythonAsync(`deriv_slope(${JSON.stringify(expr)}, ${opts.at})`); } catch{}
        if (!Number.isFinite(m)) { try { const h=1e-5; m = ((f?f(opts.at+1e-5):evalCalcAt(expr,opts.at+1e-5)) - (f?f(opts.at-1e-5):evalCalcAt(expr,opts.at-1e-5)))/(2e-5);} catch{} }
        if (Number.isFinite(m) && Number.isFinite(y0)){
          const tx=[xmin,xmax]; const ty=tx.map(x=> y0 + m*(x-opts.at));
          data.push({ x:tx, y:ty, mode:'lines', name:(lang==='ar'?'Ù…Ù…Ø§Ø³':'Tangent'), line:{ color:'#10b981', width:2.4, dash:'dash' } });
          data.push({ x:[opts.at], y:[y0], mode:'markers', name:(lang==='ar'?'Ù†Ù‚Ø·Ø©':'Point'), marker:{ color:'#10b981', size:10 } });
          addExt(ty); addExt([y0]);
          // Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ Ø¹Ù†Ø¯ x=a Ù…Ø¹ ÙˆØ³Ù…
          shapes.push({ type:'line', x0:opts.at, x1:opts.at, y0:0, y1:1, xref:'x', yref:'paper', line:{ color:'#6b7280', width:1, dash:'dot' }});
          annotations.push({ x:opts.at, xanchor:'center', y:1, yref:'paper', yshift:14, text:(lang==='ar'? 'x=a':'x=a'), showarrow:false, font:{ size:isMobile?10:11 } });
        }
      }
      if (opts && opts.mode==='int' && opts.bounds){
        const a0 = Math.min(opts.bounds[0], opts.bounds[1]);
        const b0 = Math.max(opts.bounds[0], opts.bounds[1]);
        const xi=[], yi=[]; const n2 = Math.max(40, Math.round(N*(b0-a0)/(xmax-xmin)));
        for(let i=0;i<n2;i++){ const x=a0 + (i*(b0-a0))/(n2-1); xi.push(x); try{ yi.push(f?f(x):evalCalcAt(expr,x)); } catch{ yi.push(NaN); } }
        data.push({ x: xi.concat([b0,a0]), y: yi.concat([0,0]), type:'scatter', fill:'toself', name:(lang==='ar'?'Ù…Ø³Ø§Ø­Ø©':'Area'), line:{ color:'rgba(167,139,250,.7)' }, fillcolor:'rgba(167,139,250,.18)' });
        addExt(yi);
        // Ø¹Ø²Ù‘Ø² Ø§Ù„Ù…Ø¬Ø§Ù„ Ø¨Ù‚ÙŠÙ… Ø§Ù„Ø·Ø±ÙÙŠÙ† Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± y Ø§Ù„ÙƒØ¨ÙŠØ±Ø© (Ù…Ø«Ù„ f(x)=5)
        try {
          const ya = f? f(a0) : evalCalcAt(expr, a0);
          const yb = f? f(b0) : evalCalcAt(expr, b0);
          addExt([ya, yb]);
        } catch{}
        // Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÙŠØ© Ø¹Ù†Ø¯ a Ùˆ b ÙˆØ¹Ù†Ø§ÙˆÙŠÙ† ÙˆØ§Ø¶Ø­Ø©
        shapes.push({ type:'line', x0:a0, x1:a0, y0:0, y1:1, xref:'x', yref:'paper', line:{ color:'#6b7280', width:1, dash:'dot' }});
        shapes.push({ type:'line', x0:b0, x1:b0, y0:0, y1:1, xref:'x', yref:'paper', line:{ color:'#6b7280', width:1, dash:'dot' }});
        annotations.push({ x:a0, xanchor:'center', y:1, yref:'paper', yshift:14, text:'a', showarrow:false, font:{ size:isMobile?10:11 } });
        annotations.push({ x:b0, xanchor:'center', y:1, yref:'paper', yshift:14, text:'b', showarrow:false, font:{ size:isMobile?10:11 } });
        // Ø§Ø¬Ø¹Ù„ Ù…Ø­ÙˆØ± Y Ø¯Ø§Ø¦Ù…Ù‹Ø§ ÙŠØ´Ù…Ù„ Ø§Ù„ØµÙØ± Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø­ØªÙ‰ Ø§Ù„Ø£Ø³Ø§Ø³
        try { yMin = Math.min(yMin, 0); } catch {}
      }
      // fallback/ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ù…Ø¬Ø§Ù„ Ø§Ù„Ø±Ø£Ø³ÙŠ: ÙÙŠ Ø­Ø§Ù„ Ø¯Ø§Ù„Ø© Ø«Ø§Ø¨ØªØ© Ø£Ùˆ Ù‚ÙŠÙ… Ù…ØªÙ‚Ø§Ø±Ø¨Ø©
      if (!(yMin<yMax)) {
        let v = NaN;
        try { const mid = (xmin+xmax)/2; v = f? f(mid) : evalCalcAt(expr, mid); } catch{}
        if (!Number.isFinite(v)) {
          const num = parseFloat(String(expr).trim());
          if (Number.isFinite(num)) v = num;
        }
        if (Number.isFinite(v)) { yMin = v - 1; yMax = v + 1; }
        else { yMin=-1; yMax=1; }
      }
      if ((yMax - yMin) < 1e-6) {
        const c = (yMax + yMin)/2; yMin = c - 1; yMax = c + 1;
      }
      const padY = Math.max(0.1, Math.abs(yMax-yMin)*0.12);
      const fontColor = (theme==='light')? '#0f172a' : '#e5e7eb';
      const gridColor = 'rgba(255,255,255,0.12)';
      const zeroColor = 'rgba(255,255,255,0.26)';
      // layout with shapes/annotations; we add the y label after
      const layout = {
        margin:isMobile?{l:26,r:12,t:8,b:36}:{l:40,r:18,t:12,b:42},
        paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', font:{ color:fontColor, size:isMobile?12:14 },
        xaxis:{ title:(lang==='ar'?'Ø§Ù„Ù…ØªØºÙŠØ± x':'x'), range:[xmin,xmax], gridcolor:gridColor, zeroline:true, zerolinecolor:zeroColor },
        yaxis:{ title:'', range:[yMin-padY, yMax+padY], gridcolor:'rgba(255,255,255,0.12)', zeroline:true, zerolinecolor:'rgba(255,255,255,0.2)' },
        showlegend:true,
        legend: isMobile? {orientation:'v', x:0, y:1.02} : {orientation:'h'},
        hovermode:'x unified',
        shapes,
        annotations
      };
      try { annotations.push({ xref:'paper', yref:'paper', x:-0.06, y:0.5, text:'y', showarrow:false, textangle:0, align:'center', font:{ color:fontColor, size:isMobile?12:14 }, captureevents:false }); } catch{}
      try{ Plotly.react(target, data, layout, { responsive:true, displaylogo:false, displayModeBar:false }); } catch{}
    }

    // Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø© "Ø§Ù„ØªØ¹Ø¨ÙŠØ±" Ù…Ù† Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ù†Ù‘ØµÙŠ Ø£Ùˆ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ ÙˆØ­ÙˆÙ‘Ù„ LaTeX Ø¥Ù„Ù‰ Ù†Øµ Ø¥Ù† Ù„Ø²Ù…
    function getExprInput(){
      const em = document.getElementById('exprMath');
      const et = document.getElementById('exprText');
      let v = '';
      try {
        const mfVisible = em && em.style.display !== 'none';
        if (mfVisible && em.getValue) v = String(em.getValue('latex')||'');
        else v = String(et ? et.value||'' : '');
      } catch { v = String(et ? et.value||'' : ''); }
      v = String(v||'').trim();
      if (/\\[A-Za-z]+/.test(v)) {
        try { v = latexToJSExprCached(v).replace(/Math\./g, ''); } catch {}
      }
      return v;
    }

    function evalAt(expr, xval) {
      const safe = sanitizeExpr(expr);
      if (!safe) throw new Error('invalid');
      // Inject variable x safely
      const js = `const x=${xval}; return (${safe});`;
      // eslint-disable-next-line no-new-func
      return Function(js)();
    }

    function evalCalcAt(expr, xval){
      const safe = sanitizeCalcExpr(expr);
      if (!safe) throw new Error('invalid');
      const js = `const x=${xval}; return (${safe});`;
      return Function(js)();
    }

    // Compile expression once into a fast JS function f(x)
    function compileExprFn(expr){
      const safe = sanitizeExpr(expr);
      if (!safe) throw new Error('invalid');
      // eslint-disable-next-line no-new-func
      const fn = new Function('x', `return (${safe});`);
      return function(x){ return fn(x); };
    }

    function compileCalcExprFn(expr){
      const safe = sanitizeCalcExpr(expr);
      if (!safe) throw new Error('invalid');
      const fn = new Function('x', `return (${safe});`);
      return function(x){ return fn(x); };
    }

    function estimateLimitWithFn(f, a){
      const xs = [1e-4, 5e-5, -5e-5, 1e-5, -1e-5].map(d => a + d);
      const vals = [];
      for (const xv of xs) {
        const v = f(xv);
        if (!Number.isFinite(v)) throw new Error('nonfinite');
        vals.push(v);
      }
      vals.sort((p,q)=>p-q);
      return vals[Math.floor(vals.length/2)];
    }

    function estimateLimit(expr, a) {
      // Evaluate near selected point a and average robustly
      const xs = [1e-4, 5e-5, -5e-5, 1e-5, -1e-5].map(d => a + d);
      const vals = [];
      for (const xv of xs) {
        const v = evalAt(expr, xv);
        if (!Number.isFinite(v)) throw new Error('nonfinite');
        vals.push(v);
      }
      // median for robustness
      vals.sort((a,b)=>a-b);
      const mid = vals[Math.floor(vals.length/2)];
      return mid;
    }

    function sanitizeAnswer(ans) {
      // Only numeric expression: digits + operators + () + spaces
      const ok = /^[\s0-9+\-*/().]*$/.test(ans);
      if (!ok) return null;
      const js = `return (${ans});`;
      // eslint-disable-next-line no-new-func
      return Function(js)();
    }

    function randomReactionWithIndex() {
      if (reactionList.length === 0) {
        const idx = 1 + Math.floor(Math.random()*11);
        return { src: `reactions/reaction${idx}.jpg`, idx };
      }
      const pick = reactionList[Math.floor(Math.random()*reactionList.length)];
      const m = String(pick).match(/(\d+)/);
      const idx = m ? parseInt(m[1], 10) : 1;
      return { src: `reactions/${pick}`, idx };
    }

    function showSuccess(value) {
      const r = document.getElementById('result');
      const s = STR[lang];
      // Phrase resolution: custom messages may define 'success'; else default; else STR.success
      const customMap = (reactionMessages && reactionMessages[lang]) ? reactionMessages[lang] : null;
      let phrase = '';
      if (customMap && Object.prototype.hasOwnProperty.call(customMap, 'success')) {
        const p = String(customMap['success']||'').trim();
        if (p) phrase = p;
      }
      if (!phrase) {
        const p2 = String(SUCCESS_MSG_DEFAULT[lang]||'').trim();
        if (p2) phrase = p2;
      }
      const phraseHTML = phrase ? `<h3 class='fade-in headline'>${phrase}</h3>` : `<p class='fade-in'>${s.success}</p>`;
      const imageHTML = `<img class='reaction-img' src='reactions/${SUCCESS_REACTION_NAME}' loading='lazy' alt='reaction' />`;
      r.classList.remove('fail-card'); r.classList.add('success-card');
      r.innerHTML = `<div class='reaction pop-in'>ğŸ‘ğŸ˜„ğŸ‰</div>${phraseHTML}<p class='muted fade-in'>${(lang==='ar'?'Ø§Ù„Ù‚ÙŠÙ…Ø© ~ ':'Value ~ ')} ${value.toFixed(6)}</p><br/>${imageHTML}<br/><button id='copyBtn' class='btn-outline'>${s.copy}</button>`;
      if (!playApplauseHQ()) smoothPlay('applause', 600);
      lastValue = value;
      attachCopy();
      emojiBurst();
    }

    function orderedReactionWithIndex(){
      let failCount = 0;
      try { failCount = attempts.filter(x=>x===0).length; } catch{}
      // Ø¥Ø°Ø§ ØªÙˆÙØ± manifestØŒ Ø¯ÙˆÙ‘Ø± Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ±Ù‡ + Ø¥Ø¯Ø®Ø§Ù„ Ø®Ø§Øµ Ù„Ù„Ø¹Ø¨Ø§Ø±Ø© ÙÙ‚Ø· (18)
      if (reactionList && reactionList.length) {
        const base = failCount >= 1 ? failCount : 1;
        const total = reactionList.length + 1; // Ø²Ø§Ø¦Ø¯ 1 Ù„Ù„Ø¹Ø¨Ø§Ø±Ø© Ø±Ù‚Ù… 18
        const pos = ((base - 1) % total);
        if (pos < reactionList.length) {
          const pick = reactionList[pos];
          const m = String(pick).match(/(\d+)/);
          const idx = m ? parseInt(m[1], 10) : pos + 1;
          return { src: `reactions/${pick}`, idx };
        } else {
          return { src: null, idx: 18 };
        }
      }
      // Ø®Ù„Ø§Ù Ø°Ù„ÙƒØŒ Ø§Ø³ØªØ®Ø¯Ù… ØªØ¯ÙˆÙŠØ± Ø±Ù‚Ù…ÙŠ Ø­ØªÙ‰ 18ØŒ Ùˆ18 Ø¨Ø¯ÙˆÙ† ØµÙˆØ±Ø©
      const maxIdx = 18;
      const base = failCount >= 1 ? failCount : 1;
      let idx = ((base - 1) % maxIdx) + 1;
      if (!Number.isFinite(idx) || idx < 1) idx = 1;
      if (idx === 18) return { src: null, idx };
      return { src: `reactions/reaction${idx}.jpg`, idx };
    }
    function showFailure(value) {
      const r = document.getElementById('result');
      const s = STR[lang];
      const rr = orderedReactionWithIndex();
      // Prefer a non-empty custom phrase, else fallback to default map,
      // and finally to the generic fail string.
      const key = String(rr.idx);
      const customMap = (reactionMessages && reactionMessages[lang]) ? reactionMessages[lang] : null;
      const defMap = REACTION_MSG_DEFAULT[lang];
      let phrase = '';
      if (customMap && Object.prototype.hasOwnProperty.call(customMap, key)) {
        const p = String(customMap[key]||'').trim();
        if (p) phrase = p;
      }
      if (!phrase && defMap && Object.prototype.hasOwnProperty.call(defMap, key)) {
        const p2 = String(defMap[key]||'').trim();
        if (p2) phrase = p2;
      }
      if (!phrase) phrase = s.fail;
      const phraseHTML = phrase ? `<h3 class='fade-in headline'>${phrase}</h3>` : '';
      const imageHTML = rr.src ? `<img class='reaction-img' src='${rr.src}' loading='lazy' alt='reaction' />` : '';
      r.classList.remove('success-card'); r.classList.add('fail-card');
      r.innerHTML = `<div class='reaction pop-in'>ğŸ˜•</div>${phraseHTML}<p class='muted fade-in'>${(lang==='ar'?'Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© ~ ':'Expected ~ ')} ${value.toFixed(6)}</p><br/>${imageHTML}<br/><button id='copyBtn' class='btn-outline'>${s.copy}</button>`;
      lastValue = value;
      attachCopy();
    }

    function sinSeriesLatex(n){
      const terms = [];
      // odd terms: 1,3,5,7 up to n
      for(let k=1;k<=n;k+=2){
        const sign = ((k-1)/2)%2===0 ? '' : '-';
        const fact = `\\frac{x^{${k}}}{${k}!}`;
        terms.push(`${sign}${k===1? 'x': fact}`);
      }
      return `\\(\\sin(x) = ${terms.join(' + ').replace(/\+ -/g,' - ')} + \\cdots\\)`;
    }
    function cosSeriesLatex(n){
      const terms=[];
      for(let j=0;j<=n;j+=2){
        const k=j; // power
        const sign = (k/2)%2===0 ? '' : '-';
        const term = k===0? '1' : `\\frac{x^{${k}}}{${k}!}`;
        terms.push(`${sign}${term}`);
      }
      return `\\(\\cos(x) = ${terms.join(' + ').replace(/\+ -/g,' - ')} + \\cdots\\)`;
    }
    function tanSeriesLatex(n){
      // coefficients up to x^11
      const coeff = {1:'',3:'\\frac{1}{3}',5:'\\frac{2}{15}',7:'\\frac{17}{315}',9:'\\frac{62}{2835}',11:'\\frac{1382}{155925}'};
      const powers = [1,3,5,7,9].filter(p=>p<=n);
      const p2 = n>=11? [...powers,11]: powers;
      const terms = p2.map(p=>`${p===1? 'x': coeff[p]+'x^{'+p+'}'}`);
      return `\\(\\tan(x) = ${terms.join(' + ')} + \\cdots\\)`;
    }
    // ØªØ­ÙˆÙŠÙ„ Ø­Ø§ØµÙ„ Ù‚Ø³Ù…Ø© Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¥Ù„Ù‰ \dfrac Ù…Ø¹ ØªÙ†Ø³ÙŠÙ‚ Ø¯Ø§Ø®Ù„ÙŠ ÙˆØ§Ø¶Ø­
    function toLatex(s){
      if (!s) return '';
      const clean = String(s).replace(/\s+/g, '');
      // Ø§Ø¨Ø­Ø« Ø¹Ù† / Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…Ù‚ 0 (Ø®Ø§Ø±Ø¬ Ø§Ù„Ø£Ù‚ÙˆØ§Ø³) Ù„ØªØ­ÙˆÙŠÙ„Ù‡ Ø¥Ù„Ù‰ \dfrac
      let idx = -1, depth = 0;
      for (let i=0;i<clean.length;i++){
        const ch = clean[i];
        if (ch === '(') depth++;
        else if (ch === ')') depth = Math.max(0, depth-1);
        else if (ch === '/' && depth === 0){ idx = i; break; }
      }
      const convTerm = (term)=>{
        if (!term) return '';
        let t = term;
        // Ø¯ÙˆØ§Ù„ Ù…Ø«Ù„Ø«ÙŠØ©
        t = t.replace(/sin\(/g, '\\sin(')
             .replace(/cos\(/g, '\\cos(')
             .replace(/tan\(/g, '\\tan(');
        // Ø§Ù„Ø£Ø³
        t = t.replace(/\*\*/g, '^');
        t = t.replace(/\^(\d+)/g, '^{ $1 }');
        // Ø¶Ø±Ø¨ Ø¶Ù…Ù†ÙŠ: Ø£Ø²Ù„ *
        t = t.replace(/\*/g, ' ');
        // Ø£Ù‚ÙˆØ§Ø³ Ø²Ø§Ø¦Ø¯Ø©
        t = t.replace(/\(\)/g, '');
        return t;
      };
      if (idx !== -1){
        let num = clean.slice(0, idx);
        let den = clean.slice(idx+1);
        // Ø£Ø²Ù„ Ø£Ù‚ÙˆØ§Ø³ Ø®Ø§Ø±Ø¬ÙŠØ© Ø¥Ù† ÙˆØ¬Ø¯Øª
        if (num.startsWith('(') && num.endsWith(')')) num = num.slice(1, -1);
        if (den.startsWith('(') && den.endsWith(')')) den = den.slice(1, -1);
        const N = convTerm(num);
        const D = convTerm(den);
        return `\\dfrac{${N}}{${D}}`;
      }
      return convTerm(clean);
    }
    function showSteps(expr) {
      const s = STR[lang];
      const r = document.getElementById('result');
      let html = '';
      html += `<p><strong>${(lang==='ar'?'Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©:':'Expression:')}</strong> ${expr}</p>`;
      html += `<p><strong>${(lang==='ar'?'ØªÙˆØ³ÙŠØ¹Ø§Øª Ù…Ø§ÙƒÙ„ÙˆØ±ÙŠÙ†:':'Maclaurin expansions:')}</strong></p>`;
      const n = parseInt(document.getElementById('order').value);
      const expansions = [sinSeriesLatex(n), cosSeriesLatex(n), tanSeriesLatex(n)];
      html += `<div>${expansions.map(e=>`<div>${e}</div>`).join('')}</div>`;
      try {
        const a = getApproachValue();
        const aText = getApproachLabel();
        const L = estimateLimit(expr, a);
        html += `<p><strong>${STR[lang].limitAs} ${aText}:</strong> ~ ${L.toFixed(6)}</p><br/><button id='copyBtn' class='btn-outline'>${STR[lang].copy}</button>`;
        lastValue = L; attachCopy();
      } catch(e) {
        html += `<p>${s.invalid}</p>`;
      }
      r.innerHTML = html;
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
    }

    document.getElementById('check').addEventListener('click', () => {
      const expr = getExprInput();
      const ansMf = document.getElementById('ansMath'); const ansTx = document.getElementById('ansText');
      let ans = '';
      try {
        const mfVisible = ansMf && ansMf.style.display !== 'none';
        if (mfVisible && ansMf.getValue) ans = String(ansMf.getValue('latex')||'').trim();
        else ans = String(ansTx ? ansTx.value||'' : '').trim();
      } catch { ans = String(ansTx ? ansTx.value||'' : '').trim(); }
      const res = document.getElementById('result');
      if (mode === 'solve') {
        // hide answer field in solve mode
        document.getElementById('ansBlock').style.display = 'none';
        try {
          const a = getApproachValue();
          const aText = getApproachLabel();
          const L = (function(){ try { const f = compileExprFn(expr); return estimateLimitWithFn(f, a);} catch { return estimateLimit(expr, a);} })();
          res.innerHTML = `<div id='solutionGraph' class='fade-in' style='margin-bottom:8px;'></div><p class='fade-in'><strong>${STR[lang].limitAs} ${aText}:</strong> ~ ${L.toFixed(6)}</p>`;
          // Draw a compact, read-only solution graph beneath the answer
          try { renderSolutionGraph(expr, a, L); } catch {}
        } catch(e) {
          res.innerHTML = `<div class='reaction pop-in'>ğŸ˜•</div><p class='fade-in'>${STR[lang].invalid}</p>`;
        }
      } else if (mode === 'steps') {
        document.getElementById('ansBlock').style.display = 'none';
        showSteps(expr);
      } else {
        document.getElementById('ansBlock').style.display = '';
        try {
          const a = getApproachValue();
          const L = estimateLimit(expr, a);
          const user = evalLatexNumeric(ans);
          if (typeof user !== 'number' || !Number.isFinite(user)) throw new Error('bad answer');
          const ok = Math.abs(L - user) < 1e-4;
          total += 1; if (ok){ correct += 1; streak += 1; score += 1; attempts.push(1); } else { streak = 0; attempts.push(0); }
          saveStats(); updateHUD();
          if (ok) { showSuccess(L); } else { showFailure(L); }
        } catch (e) {
          res.innerHTML = `<div class='reaction'>ğŸ˜•</div><p>${STR[lang].invalid}</p>`;
        }
      }
    });

    document.getElementById('themeBtn').addEventListener('click', () => {
      theme = theme === 'light' ? 'dark' : 'light';
      const vars = theme === 'light' ? LIGHT : DARK;
      for (const k in vars) document.documentElement.style.setProperty(k, vars[k]);
      document.getElementById('themeBtn').textContent = theme === 'light' ? 'ğŸŒ™' : 'â˜€ï¸';
      try { localStorage.setItem('theme', theme);} catch {}
      populateWatermark();
    });
    document.getElementById('langBtn').addEventListener('click', () => {
      lang = lang === 'ar' ? 'en' : 'ar';
      try { localStorage.setItem('lang', lang);} catch {}
      const cont = document.querySelector('.container'); if (cont) { cont.classList.remove('fade-in'); void cont.offsetWidth; cont.classList.add('fade-in'); }
      applyLang();
    });
    document.getElementById('guideBtn').addEventListener('click', ()=>{
      const g = document.getElementById('guide');
      g.style.display = (g.style.display==='none')? '' : 'none';
    });

    // segmented control
    document.getElementById('modeSeg').addEventListener('click', (e) => {
      const btn = e.target.closest('.seg-btn');
      if (!btn) return;
      mode = btn.dataset.mode;
      document.querySelectorAll('#modeSeg .seg-btn').forEach(b=>b.classList.toggle('active', b === btn));
      // toggle order slider visibility
      document.getElementById('orderRow').style.display = (mode==='steps')? '': 'none';
      document.getElementById('ansBlock').style.display = (mode==='game')? '': 'none';
      document.getElementById('gameToolbar').style.display = (mode==='game')? '' : 'none';
      document.getElementById('hint').style.display = 'none';
      document.getElementById('hud').style.display = (mode==='game')? '' : 'none';
      const calcCard = document.getElementById('calcCard'); if (calcCard) calcCard.style.display = (mode==='calc')? '' : 'none';
      // Ø§Ø¶Ø¨Ø· a Ø¹Ø´ÙˆØ§Ø¦ÙŠÙ‹Ø§ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙˆØ¶Ø§Ø¹
      if (mode==='solve' || mode==='steps' || mode==='game') { try { setRandomApproach(); } catch{} }
      // Ø¶Ø¹ Ø®Ø§Ù†Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØªØ­Øª Ø²Ø± Ø§Ù„ØªÙ„Ù…ÙŠØ­ ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨
      const ansCont = document.getElementById('ansContainer');
      if (mode==='game') {
        updateHUD(); try { newQuestion(); } catch(_){}
        try {
          const ab = document.getElementById('ansBlock');
          if (ansCont && ab) {
            ansCont.style.display = '';
            ansCont.appendChild(ab);
          }
        } catch{}
        // hide training graph in game mode
        try { const tg = document.getElementById('trainGraph'); if (tg) tg.style.display = 'none'; } catch{}
        // show the tip on first entry to game mode
        try { const seen = localStorage.getItem('menuTipSeen'); if (!seen) { showMenuTip(); setTimeout(()=>hideMenuTip(true), 4500); } } catch{}
      } else if (mode==='calc') {
        // Ø¥Ø®ÙØ§Ø¡ Ø¹Ù†Ø§ØµØ± Ø·ÙˆØ± Ù…Ø§ÙƒÙ„ÙˆØ±ÙŠÙ† Ù„Ø¬Ø¹Ù„ Ø§Ù„ÙˆØ¶Ø¹ Ù…Ù†ÙØµÙ„ ØªÙ…Ø§Ù…Ù‹Ø§
        try {
          const exprField = document.getElementById('exprFieldContainer'); if (exprField) exprField.style.display = 'none';
          const pointField = document.getElementById('point-field-container'); if (pointField) pointField.style.display = 'none';
          const checkBtn = document.getElementById('check'); if (checkBtn) checkBtn.style.display = 'none';
          const qd = document.getElementById('questionDisplay'); if (qd) qd.style.display = 'none';
          if (ansCont) ansCont.style.display = 'none';
          // Ø£Ø¹ÙØ¯ Ø®Ø§Ù†Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¥Ù„Ù‰ Ù…ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªØºØ·ÙŠØ© Ø§Ù„Ø¹Ù†Ø§ØµØ±
          try { if (ansOrigParent && ansAnchor){ const ab = document.getElementById('ansBlock'); if (ab && ab.parentElement !== ansOrigParent) ansOrigParent.insertBefore(ab, ansAnchor.nextSibling); } } catch{}
          const tg = document.getElementById('trainGraph'); if (tg) tg.style.display = 'none';
        } catch{}
      } else {
        if (ansCont) ansCont.style.display = 'none';
        try { const tg = document.getElementById('trainGraph'); if (tg) tg.style.display = 'none'; } catch{}
        // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø¥Ù† ÙƒØ§Ù†Øª Ù…Ø®ÙÙŠØ© Ù…Ù† ÙˆØ¶Ø¹ calc
        try {
          const exprField = document.getElementById('exprFieldContainer'); if (exprField) exprField.style.display = '';
          const pointField = document.getElementById('point-field-container'); if (pointField) pointField.style.display = '';
          const checkBtn = document.getElementById('check'); if (checkBtn) checkBtn.style.display = '';
        } catch{}
        // Ø£Ø¹ÙØ¯ Ø®Ø§Ù†Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¥Ù„Ù‰ Ù…ÙˆØ¶Ø¹Ù‡Ø§ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¥Ø°Ø§ Ù„Ù… Ù†ÙƒÙ† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¯Ø±ÙŠØ¨
        try { if (mode!=='game' && ansOrigParent && ansAnchor){ const ab = document.getElementById('ansBlock'); if (ab && ab.parentElement !== ansOrigParent) ansOrigParent.insertBefore(ab, ansAnchor.nextSibling); } } catch{}
      }
    });

    // init
    (function init(){
      // theme/lang from storage
      try { theme = localStorage.getItem('theme') || theme; } catch {}
      try { lang = localStorage.getItem('lang') || lang; } catch {}
      const vars = theme==='light'? LIGHT : DARK; for (const k in vars) document.documentElement.style.setProperty(k, vars[k]);
      document.getElementById('themeBtn').textContent = theme === 'light' ? 'ğŸŒ™' : 'â˜€ï¸';
      document.getElementById('guide').textContent = STR[lang].guide;
      // ensure math field is cleanly initialized
      try { const mf = document.getElementById('ansMath'); if (mf && mf.setValue) mf.setValue('', {suppressChangeNotifications: true}); } catch {}
      // default answer visibility
      document.getElementById('ansBlock').style.display = 'none';
      document.getElementById('orderRow').style.display = 'none';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('gameToolbar').style.display = 'none';
      document.getElementById('hint').style.display = 'none';
      const ansCont = document.getElementById('ansContainer'); if (ansCont) ansCont.style.display = 'none';
      // Ø§Ø­ÙØ¸ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ø®Ø§Ù†Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù…Ø¹ Ù…Ø±Ø³Ø§Ø© Ø«Ø§Ø¨ØªØ©
      try {
        const ab = document.getElementById('ansBlock');
        ansOrigParent = ab ? ab.parentElement : null;
        if (ansOrigParent && ab) {
          ansAnchor = document.createElement('span'); ansAnchor.id = 'ansAnchor'; ansAnchor.style.display = 'none';
          ansOrigParent.insertBefore(ansAnchor, ab);
        }
      } catch{}
      // graphCard ØªÙ…Øª Ø¥Ø²Ø§Ù„ØªÙ‡
      // order slider change
      document.getElementById('order').addEventListener('input', ()=>{
        const n = parseInt(document.getElementById('order').value);
        const s = STR[lang];
        document.getElementById('orderVal').textContent = s.orderVal(n);
      });
      // apply language texts now
      applyLang();
      // Ø£Ø®ÙÙ Ø­Ù‚Ù„ Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨ Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ø³ØªØ¹Ù…Ù„ Ù‚ÙŠÙ…Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¯Ø§Ø¦Ù…Ù‹Ø§
      try { const pfc = document.getElementById('point-field-container'); if (pfc) pfc.style.display = 'none'; } catch{}
      try { setRandomApproach(); } catch{}
      try { updateApproachHUD(); } catch{}
      // ØªØ­Ù…ÙŠÙ„ SymPy Ù„ÙˆØ¶Ø¹ Ø§Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„
      initSymPy();
      // Ø±Ø¨Ø· ÙˆØ¶Ø¹ Ø§Ù„ØªÙØ§Ø¶Ù„/Ø§Ù„ØªÙƒØ§Ù…Ù„
      try {
        const seg = document.getElementById('calcModeSeg');
        if (seg) seg.addEventListener('click', function(e){
          const b = e.target.closest('.seg-btn'); if (!b) return;
          seg.querySelectorAll('.seg-btn').forEach(x=>x.classList.toggle('active', x===b));
          const mode = b.dataset.calc;
          const atRow = document.getElementById('calcAtRow');
          const bRow = document.getElementById('calcBoundsRow');
          if (mode==='diff') { if (atRow) atRow.style.display=''; if (bRow) bRow.style.display='none'; }
          else { if (atRow) atRow.style.display='none'; if (bRow) bRow.style.display=''; }
        });
      } catch{}
      try {
        const qseg = document.getElementById('calcQualitySeg');
        if (qseg) qseg.addEventListener('click', function(e){
          const b = e.target.closest('.seg-btn'); if (!b) return;
          qseg.querySelectorAll('.seg-btn').forEach(x=>x.classList.toggle('active', x===b));
        });
      } catch{}
      try {
        const run = document.getElementById('calcRun'); if (run) run.addEventListener('click', handleCalcRun);
      } catch{}
      try {
        document.addEventListener('click', function(ev){
          const t = ev.target;
          const isEl = t && t.nodeType === 1; // ELEMENT_NODE
          const btn = isEl && t.matches ? (t.matches('#calcCopy') ? t : (t.closest ? t.closest('#calcCopy') : null)) : null;
          if (!btn) return;
          try {
            const prefer = btn.getAttribute('data-val');
            let toCopy = '';
            if (prefer && prefer.length) { toCopy = prefer; }
            else {
              const box = document.getElementById('calcResult');
              if (!box) return;
              const text = box.textContent || '';
              const m = text.match(/([+\-]?[0-9]+(?:\.[0-9]+)?(?:e[+\-]?[0-9]+)?)(?!.*[0-9])/i);
              toCopy = m ? m[1] : '';
            }
            if (toCopy) { navigator.clipboard.writeText(toCopy); btn.textContent = 'Ù†ÙØ³ÙØ®Øª'; setTimeout(()=>{ btn.textContent='Ù†Ø³Ø® Ø§Ù„Ù‚ÙŠÙ…Ø©'; }, 1200); }
          } catch{}
        });
      } catch{}
      // mobile keyboard UX hooks
      setupKeyboardUX();
      setupExprUX();
      // Ø§Ø±Ø¨Ø· Ø­Ø§ÙˆÙŠØ© Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø¨Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø£Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯
      try { if (window.mathVirtualKeyboard) { 
        window.mathVirtualKeyboard.container = document.getElementById('math-field-container');
        // ØªÙØ¹ÙŠÙ„ ØªØ®Ø·ÙŠØ· ÙƒØ§Ù…Ù„ Ø¨Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
        window.mathVirtualKeyboard.layouts = 'full';
        // Ø­Ø±Ù‘Ùƒ Ø²Ø± âœ• Ù„ÙŠÙƒÙˆÙ† ÙÙˆÙ‚ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ ÙˆÙŠØªØ§Ø¨Ø¹ Ø§Ø±ØªÙØ§Ø¹Ù‡
        try {
          window.mathVirtualKeyboard.addEventListener('geometrychange', function(){
            const btn = document.getElementById('kbClose');
            const rect = window.mathVirtualKeyboard.boundingRect || {};
            if (btn) {
              const open = rect && rect.height > 0;
              btn.style.display = open ? 'block' : 'none';
              if (open) btn.style.bottom = `calc(${Math.max(0, rect.height)}px + env(safe-area-inset-bottom) + 10px)`;
            }
          });
        } catch{}
      } } catch {}
      // show menu tip once near the answer menu
      try {
        const seen = localStorage.getItem('menuTipSeen');
        if (!seen) { showMenuTip(); setTimeout(()=>hideMenuTip(true), 4500); }
      } catch {}
      // load reactions manifest + optional messages
      loadReactionsManifest();
      loadReactionMessages();
      updateHUD();
      // Ø±Ø³Ù… Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
      populateWatermark();
      window.addEventListener('resize', debounce(populateWatermark, 200));
      // Graph resize observer for mobile/orientation changes
      try {
        const g = document.getElementById('graph');
        if (g && 'ResizeObserver' in window) {
          const ro = new ResizeObserver(()=>{ try { Plotly.Plots.resize(g); } catch{} });
          ro.observe(g);
        }
        window.addEventListener('orientationchange', ()=>{ try { fitGraphHeight(); Plotly.Plots.resize(g); } catch{} });
        window.addEventListener('resize', debounce(()=>{ try { fitGraphHeight(); if (g) Plotly.Plots.resize(g); } catch{} }, 150));
      } catch {}
      // Ù…ÙØ§ØªÙŠØ­ Ø§Ø®ØªØµØ§Ø±Ø§Øª: Enter Ù„Ù„ØªØ­Ù‚Ù‚ØŒ Ctrl+N Ù„Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter') document.getElementById('check').click();
        if ((e.ctrlKey || e.metaKey) && (e.key==='n' || e.key==='N')) { e.preventDefault(); newQuestion(); }
      });
    })();
    // Fit graph div height to viewport on small screens
    function fitGraphHeight(){
      try {
        const g = document.getElementById('graph'); if (!g) return;
        const isMobile = window.innerWidth <= 640;
        if (isMobile) {
          // Match CSS clamp(260px, 50dvh, 520px)
          const vh = Math.max(260, Math.min(window.innerHeight * 0.5, 520));
          g.style.height = vh + 'px';
        } else {
          g.style.height = '420px';
        }
      } catch {}
    }
    // --- Mobile keyboard UX: dismiss button, padding, outside click ---
    function setupKeyboardUX(){
      const cont = document.querySelector('.container');
      const mf = document.getElementById('ansMath'); const dismiss = document.getElementById('kbDismiss'); const tx = document.getElementById('ansText');
      if (!cont || !mf) return;
      let kbOpen = false;
      let kbEl = null;
      let suppressOpenUntil = 0; // Ù„Ù…Ù†Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ÙØªØ­ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚
      function openKB(){
        kbOpen = true;
        // Ø¥Ø¸Ù‡Ø§Ø± Ø²Ø± Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ÙÙ‚Ø· ÙˆØªØ±Ùƒ MathLive ÙŠØ¶Ø¨Ø· Ù…ÙƒØ§Ù† Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø·Ø¨ÙŠØ¹ÙŠÙ‹Ø§
        try {
          const kbClose = document.getElementById('kbClose');
          if (kbClose) kbClose.style.display='block';
          if (dismiss) dismiss.style.display = 'block';
        } catch{}
      }
      function closeKB(){
        kbOpen = false;
        suppressOpenUntil = Date.now() + 600;
        try { if (dismiss) dismiss.style.display = 'none'; } catch{}
        try { const kbClose = document.getElementById('kbClose'); if (kbClose) kbClose.style.display='none'; } catch{}
        try{
          if (mf.hideVirtualKeyboard) mf.hideVirtualKeyboard(); else if (mf.executeCommand) mf.executeCommand('hideVirtualKeyboard');
          if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = false;
        }catch{}
      }
      // Ø§Ø¬Ø¹Ù„ Ø§Ù„Ø¯ÙˆØ§Ù„ Ù…ØªØ§Ø­Ø© Ù„Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ù…ØµØºÙ‘Ø±Ø© Ø£ÙŠØ¶Ù‹Ø§
      try { window.openMathKB = openKB; window.closeMathKB = closeKB; } catch{}
      // Ø£ØºÙ„Ù‚ Ø¹Ù†Ø¯ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØªØ±ÙƒÙŠØ².
      mf.addEventListener('blur', closeKB);
      // Ø§ÙØªØ­ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¹Ù†Ø¯ ØªØ±ÙƒÙŠØ² math-field (Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† Ø¸Ø§Ù‡Ø±Ù‹Ø§)
      mf.addEventListener('focus', function(){
        try {
          if (Date.now() < suppressOpenUntil) return;
          kbTarget = 'ans';
          openKB();
          if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = true;
          if (mf.showVirtualKeyboard) mf.showVirtualKeyboard();
          else if (mf.executeCommand) mf.executeCommand('showVirtualKeyboard');
        } catch{}
      });
      // ØªØ­ÙˆÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† Ø­Ù‚Ù„ Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ·/Ø§Ù„Ù„Ù…Ø³/Ø§Ù„ØªØ±ÙƒÙŠØ²
      if (tx) {
        const switchToMath = function(e){
          try { if (e && e.preventDefault) e.preventDefault(); } catch{}
          try { tx.setAttribute('readonly','readonly'); } catch{}
          try {
            tx.style.display = 'none';
            mf.style.display = '';
            const v = String(tx.value||'');
            if (mf.setValue) mf.setValue(v, {suppressChangeNotifications:true});
            if (mf && mf.focus) mf.focus({ preventScroll: true });
            kbTarget = 'ans';
            openKB();
            if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = true;
            if (mf.showVirtualKeyboard) mf.showVirtualKeyboard();
            else if (mf.executeCommand) mf.executeCommand('showVirtualKeyboard');
          } catch{}
        };
        tx.addEventListener('pointerdown', switchToMath);
        tx.addEventListener('touchstart', switchToMath, { passive: false });
        tx.addEventListener('click', switchToMath);
        tx.addEventListener('focus', switchToMath);
      }
      // ÙØªØ­ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Ø§Ù„Ù…Ù†ÙŠÙˆ
      const menuBtn = document.getElementById('ansMenuBtn');
      if (menuBtn) {
        menuBtn.addEventListener('click', function(){
          try {
            if (tx) tx.style.display = 'none';
            mf.style.display = '';
            const v = tx ? String(tx.value||'') : '';
            if (mf.setValue) mf.setValue(v, {suppressChangeNotifications:true});
            if (mf && mf.focus) mf.focus({ preventScroll: true });
          } catch{}
          kbTarget = 'ans';
          openKB();
          try {
            if (window.mathVirtualKeyboard) { window.mathVirtualKeyboard.visible = true; }
            if (mf.showVirtualKeyboard) mf.showVirtualKeyboard();
            else if (mf.executeCommand) mf.executeCommand('showVirtualKeyboard');
          } catch{}
          // Ø§ØªØ±Ùƒ Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ Ø¯ÙˆÙ† Ø£ÙŠ Ù‚ÙŠØ§Ø³Ø§Øª Ø£Ùˆ Ø­ÙˆØ§Ø´Ù Ø¥Ø¶Ø§ÙÙŠØ©
        });
      }
      // Dismiss button (removed)
      if (dismiss) {
        dismiss.addEventListener('click', function(){
          try { const v = mf && mf.getValue ? String(mf.getValue('latex')||'') : ''; if (tx) tx.value = v; } catch{}
          mf.style.display = 'none'; if (tx) tx.style.display='';
          try{ mf.blur(); }catch{}
          closeKB();
        });
      }
      const kbCloseBtn = document.getElementById('kbClose');
      if (kbCloseBtn) {
        const doClose = function(e){
          try { if (e) { e.preventDefault(); e.stopPropagation(); } } catch{}
          try { document.activeElement.blur(); } catch{}
          try {
            const amf = document.getElementById('ansMath'); const atx = document.getElementById('ansText');
            const emf = document.getElementById('exprMath'); const etx = document.getElementById('exprText');
            const activeMf = kbTarget === 'expr' ? emf : amf;
            const activeTx = kbTarget === 'expr' ? etx : atx;
            const v = activeMf && activeMf.getValue ? String(activeMf.getValue('latex')||'') : '';
            if (activeTx) activeTx.value = v;
            if (activeMf) activeMf.style.display = 'none'; if (activeTx) activeTx.style.display='';
          } catch{}
          closeKB();
        };
        kbCloseBtn.addEventListener('click', doClose);
        kbCloseBtn.addEventListener('pointerdown', doClose);
        kbCloseBtn.addEventListener('touchstart', doClose, { passive: false });
      }
      // Outside click to blur (bubble phase + robust shadow DOM path check)
      document.addEventListener('click', function(e){
        if (!(window.mathVirtualKeyboard && window.mathVirtualKeyboard.visible)) return;
        const path = (typeof e.composedPath === 'function') ? e.composedPath() : [];
        const inPath = (selector) => path.some(n => n && n.nodeType === 1 && (n.matches?.(selector) || n.closest?.(selector)));
        const withinField = inPath('#ansMath') || inPath('#exprMath');
        const withinKB = inPath('.ML__keyboard');
        const withinPad = inPath('#ansPad');
        const withinMenu = inPath('#ansMenu');
        const withinClose = inPath('#kbClose');
        if (!withinField && !withinKB && !withinPad && !withinMenu && !withinClose) {
          try {
            const amf = document.getElementById('ansMath'); const atx = document.getElementById('ansText');
            const emf = document.getElementById('exprMath'); const etx = document.getElementById('exprText');
            const activeMf = kbTarget === 'expr' ? emf : amf;
            const activeTx = kbTarget === 'expr' ? etx : atx;
            const v = activeMf && activeMf.getValue ? String(activeMf.getValue('latex')||'') : '';
            if (activeTx) activeTx.value = v;
            if (activeMf) activeMf.style.display = 'none'; if (activeTx) activeTx.style.display='';
            try{ activeMf.blur(); }catch{}
          } catch{}
          closeKB();
        }
      });
      // Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ø£ÙŠ Ù‚ÙŠØ§Ø³Ø§Øª/Ù…Ø±Ø§Ù‚Ø¨Ø§Øª: Ù†Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ ØªÙ…ÙˆØ¶Ø¹ MathLive Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ
    }

    // ØªÙ…ÙƒÙŠÙ† Ù†ÙØ³ ØªØ¬Ø±Ø¨Ø© Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ù„Ø­Ù‚Ù„ Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø§Ù„ØªØ¹Ø¨ÙŠØ±)
    function setupExprUX(){
      const em = document.getElementById('exprMath');
      const et = document.getElementById('exprText');
      if (!em || !et) return;
      let suppressOpenUntil = 0;
      function openKB(){
        try { const kbClose = document.getElementById('kbClose'); if (kbClose) kbClose.style.display='block'; } catch{}
      }
      function closeKB(){
        suppressOpenUntil = Date.now() + 600;
        try { const kbClose = document.getElementById('kbClose'); if (kbClose) kbClose.style.display='none'; } catch{}
        try{
          if (em.hideVirtualKeyboard) em.hideVirtualKeyboard(); else if (em.executeCommand) em.executeCommand('hideVirtualKeyboard');
          if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = false;
        }catch{}
      }
      em.addEventListener('blur', closeKB);
      em.addEventListener('focus', function(){
        try {
          if (Date.now() < suppressOpenUntil) return;
          kbTarget = 'expr';
          openKB();
          if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = true;
          if (em.showVirtualKeyboard) em.showVirtualKeyboard(); else if (em.executeCommand) em.executeCommand('showVirtualKeyboard');
        } catch{}
      });
      const switchToMath = function(e){
        try { if (e && e.preventDefault) e.preventDefault(); } catch{}
        try { et.setAttribute('readonly','readonly'); } catch{}
        try {
          et.style.display = 'none';
          em.style.display = '';
          const v = String(et.value||'');
          if (em.setValue) em.setValue(v, {suppressChangeNotifications:true});
          if (em && em.focus) em.focus({ preventScroll: true });
          kbTarget = 'expr';
          openKB();
          if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = true;
          if (em.showVirtualKeyboard) em.showVirtualKeyboard(); else if (em.executeCommand) em.executeCommand('showVirtualKeyboard');
        } catch{}
      };
      et.addEventListener('pointerdown', switchToMath);
      et.addEventListener('touchstart', switchToMath, { passive: false });
      et.addEventListener('click', switchToMath);
      et.addEventListener('focus', switchToMath);
    }

    // Smooth audio play (fade-in)
    function smoothPlay(id, fadeMs=600){
      const a = document.getElementById(id);
      try{
        a.pause(); a.currentTime = 0; a.volume = 0; a.play();
        const steps = 30; const inc = 1/steps; let i=0;
        const t = setInterval(()=>{ i++; a.volume = Math.min(1, a.volume + inc); if(i>=steps){ clearInterval(t);} }, Math.max(20, fadeMs/steps));
      }catch(e){ a.play(); }
    }
    function attachCopy(){
      const btn = document.getElementById('copyBtn');
      if (!btn) return;
      btn.onclick = async ()=>{
        try {
          await navigator.clipboard.writeText(String(lastValue));
          btn.textContent = (lang==='ar'? 'âœ… ØªÙ… Ø§Ù„Ù†Ø³Ø®' : 'âœ… Copied');
          setTimeout(()=>{ btn.textContent = STR[lang].copy; }, 1200);
        } catch {}
      };
    }
    // Score & progress
    score = 0; attempts = [];
    try { score = parseInt(localStorage.getItem('score')||'0')||0; attempts = JSON.parse(localStorage.getItem('attempts')||'[]')||[]; } catch {}
    streak = 0; correct = 0; total = 0;
    try { streak = parseInt(localStorage.getItem('streak')||'0')||0; correct = parseInt(localStorage.getItem('correct')||'0')||0; total = parseInt(localStorage.getItem('total')||'0')||0; } catch {}
    try { if (typeof updateHUD === 'function') updateHUD(); } catch {}
    function saveStats(){
      try{
        localStorage.setItem('score', String(score));
        localStorage.setItem('attempts', JSON.stringify(attempts.slice(-10)));
        localStorage.setItem('streak', String(streak));
        localStorage.setItem('correct', String(correct));
        localStorage.setItem('total', String(total));
      } catch{}
    }
    function updateHUD(){
      const s = STR[lang];
      const lbl = document.getElementById('scoreLabel'); if (lbl) lbl.textContent = s.points(score);
      const recent = attempts.slice(-10); const okCount = recent.filter(x=>x===1).length; const pct = recent.length? Math.round((okCount/recent.length)*100) : 0;
      const pf = document.getElementById('progressFill'); if (pf) pf.style.width = pct+'%';
      const st = document.getElementById('streakLabel'); if (st) st.textContent = (lang==='ar'? `Ø³Ù„Ø³Ù„Ø© ØµØ­ÙŠØ­Ø©: ${streak}ğŸ”¥` : `Streak: ${streak}ğŸ”¥`);
      const ac = document.getElementById('accLabel'); if (ac) {
        const acc = total? Math.round((correct/total)*100) : 0;
        ac.textContent = (lang==='ar'? `Ø§Ù„Ø¯Ù‚Ø©: ${acc}%` : `Accuracy: ${acc}%`);
      }
    }
    document.getElementById('resetScore').addEventListener('click', ()=>{ score=0; attempts=[]; streak=0; correct=0; total=0; saveStats(); updateHUD(); });
    function emojiBurst(){
      const overlay = document.getElementById('overlay');
      const emojis = ['ğŸ‰','âœ¨','ğŸ‘','ğŸŠ','ğŸ¥³'];
      for(let i=0;i<16;i++){
        const span = document.createElement('span');
        span.className = 'confetti';
        span.style.left = (20 + Math.random()*80)+'%';
        span.style.top = '8px';
        span.textContent = emojis[Math.floor(Math.random()*emojis.length)];
        overlay.appendChild(span);
        setTimeout(()=>{ span.remove(); }, 1000);
      }
    }
    // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…Ø§Ø¦ÙŠØ© sin/cos/tan Ø¨Ø´ÙƒÙ„ Ù…ÙˆØ²Ø¹
    function populateWatermark(){
      const cont = document.getElementById('wm'); if (!cont) return;
      cont.innerHTML = '';
      const words = ['sin','cos','tan'];
      const W = window.innerWidth, H = window.innerHeight;
      const count = Math.min(28, Math.max(10, Math.round((W*H)/45000)));
      for(let i=0;i<count;i++){
        const s = document.createElement('span');
        s.textContent = words[i % words.length];
        const left = Math.random()*90; const top = Math.random()*90;
        const rot = (Math.random()*30 - 15).toFixed(1);
        s.style.left = left+'%'; s.style.top = top+'%'; s.style.transform = `rotate(${rot}deg)`;
        cont.appendChild(s);
      }
    }
    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(null,a), ms); } }
    async function loadReactionsManifest(){
      try {
        const res = await fetch('reactions/manifest.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('no manifest');
        const data = await res.json();
        if (Array.isArray(data) && data.length) reactionList = data.filter(n=>/\.jpg$/i.test(n));
      } catch(e) {
        // fallback is handled in randomReaction()
      }
    }
    async function loadReactionMessages(){
      try {
        const res = await fetch('reactions/messages.json', { cache: 'no-store' });
        if (res.ok) {
          const data = await res.json();
          if (data && (data.ar || data.en)) reactionMessages = data;
        }
      } catch(e) { /* optional file */ }
    }
    // Ø¨Ù†Ùƒ Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨
    const BANK = {
      easy: [
        'sin(x)/x', 'tan(x)/x', '(1-cos(x))/x**2',
        'sin(2*x)/(2*x)', 'tan(2*x)/(2*x)', '(1-cos(2*x))/(2*x**2)'
      ],
      med: [
        '(sin(x)-x)/x**3', '(1-cos(x))/ (x**2)', 'tan(3*x)/(3*x)',
        '(sin(3*x))/(3*x)', '(1-cos(3*x))/(x**2)'
      ],
      hard: [
        '(sin(x)-x + x**3/6)/x**5', '(tan(x)-x)/x**3', '(1-cos(2*x)-2*x**2)/x**4'
      ]
    };
    let difficulty = 'easy';
    function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function newQuestion(){
      try { setRandomApproach(); } catch{}
      const list = BANK[difficulty] || BANK.easy;
      const q = pickRandom(list);
      const exprText = document.getElementById('exprText');
      const exprMath = document.getElementById('exprMath');
      const ansMf = document.getElementById('ansMath');
      // Build question according to current approach point
      let evalQ = q;
      try {
        const a = (typeof getApproachValue==='function') ? getApproachValue() : 0;
        if (a !== 0) {
          const aNum = Number(a);
          const aStr = '(' + (Number.isFinite(aNum) ? aNum.toPrecision(12) : String(a)) + ')';
          // replace variable x tokens with (x - a)
          evalQ = q.replace(/\bx\b/g, `(x - ${aStr})`);
        }
      } catch {}
      exprText.value = evalQ; if (exprMath && exprMath.setValue) exprMath.setValue('', {suppressChangeNotifications: true});
      if (exprMath) exprMath.style.display = 'none'; if (exprText) exprText.style.display='';
      document.getElementById('result').innerHTML = '';
      document.getElementById('result').classList.remove('success-card','fail-card');
      document.getElementById('hint').style.display = 'none';
      const hm = document.getElementById('hintMini'); if (hm) hm.style.display = 'none'; hm && (hm.innerHTML = '');
      const ah = document.getElementById('ansHelp'); if (ah) ah.style.display='';
      // Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¨Ø´ÙƒÙ„ Ù„Ø§ØªÙƒØ³ Ù…Ù†Ø³Ù‘Ù‚
      try {
        const card = document.getElementById('questionDisplay');
        if (card) {
          card.style.display = '';
          let latex;
          try {
            const aText = (typeof getApproachLabel==='function') ? getApproachLabel() : '0';
            if (aText && aText !== '0') {
              // create a symbolic display using x - (Ï€/4) or x - Ï€
              const aLatex = (aText === 'Ï€/4') ? '\\frac{\\pi}{4}' : (aText === 'Ï€' ? '\\pi' : aText);
              const displayQ = q.replace(/\bx\b/g, `(x - ${aLatex})`);
              latex = toLatex(displayQ);
            } else {
              latex = toLatex(exprText.value.trim());
            }
          } catch { latex = toLatex(exprText.value.trim()); }
          card.innerHTML = `<div style='font-size:1.2rem'>\\(${latex}\\)</div>`;
          if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
        }
      } catch{}
      exprText.focus();
    }
    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØµØ¹ÙˆØ¨Ø© + Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯ + ØªÙ„Ù…ÙŠØ­
    (function bindGameControls(){
      var diffSeg = document.getElementById('diffSeg');
      if (diffSeg) {
        diffSeg.addEventListener('click', function(e){
          const btn = e.target.closest('.seg-btn'); if (!btn) return;
          difficulty = btn.dataset.diff;
          document.querySelectorAll('#diffSeg .seg-btn').forEach(function(b){ b.classList.toggle('active', b===btn); });
        });
      }
      var newQBtn = document.getElementById('newQ'); if (newQBtn) newQBtn.addEventListener('click', newQuestion);
      var hintBtn = document.getElementById('hintBtn'); if (hintBtn) hintBtn.addEventListener('click', function(){
      const hintMini = document.getElementById('hintMini');
      const hint = document.getElementById('hint');
      const expr = getExprInput();
      const need = { sin: /sin\s*\(/.test(expr), cos: /cos\s*\(/.test(expr), tan: /tan\s*\(/.test(expr) };
      let html = '';
      const aText = (typeof getApproachLabel==='function') ? getApproachLabel() : '0';
      html += `<div><strong>${(lang==='ar'?'ØªÙ„Ù…ÙŠØ­Ø§Øª Ø§Ù„Ø³Ù„Ø³Ù„Ø©:':'Series hints:')}</strong></div>`;
      if (aText !== '0') {
        html += `<div class='muted'>${(lang==='ar'? 'Ø§Ù‚ØªØ±Ø¨ Ù…Ù† ':'Approach at ')} xâ†’${aText}. ${(lang==='ar'?'Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ­ÙˆÙŠÙ„ ':'Use substitution ')} u = x - ${aText} ${(lang==='ar'?'Ø«Ù… Ø·Ø¨Ù‘ÙÙ‚ ØªÙˆØ³Ø¹Ø§Øª Ù…Ø§ÙƒÙ„ÙˆØ±ÙŠÙ† Ø­ÙˆÙ„ uâ†’0.':'then apply Maclaurin expansions at uâ†’0.')}</div>`;
      }
      const n = parseInt(document.getElementById('order').value);
      if (need.sin) html += `<div>${sinSeriesLatex(n)}</div>`;
      if (need.cos) html += `<div>${cosSeriesLatex(n)}</div>`;
      if (need.tan) html += `<div>${tanSeriesLatex(n)}</div>`;
      if (hintMini) { hintMini.innerHTML = html; hintMini.style.display = hintMini.style.display==='none'? '' : 'none'; }
      else { hint.innerHTML = html; hint.style.display = hint.style.display==='none'? '' : 'none'; }
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
      });
    })();
    // Ø£Ø²Ø±Ø§Ø± MathLive: Ø¥Ø¯Ø±Ø§Ø¬ Ù‚ÙˆØ§Ù„Ø¨ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù‚Ù„ WYSIWYG
    function handleInsMath(type){
      const mf = document.getElementById('ansMath'); if (!mf) return;
      if (type==='frac') {
        // Insert fraction with placeholders without moving focus
        mf.insert('\\frac{\\placeholder{}}{\\placeholder{}}');
      }
      else if (type==='pow') mf.insert('^{ }');
      else if (type==='sqrt') mf.insert('\\sqrt{}');
      else if (type==='parens') mf.insert('\\left(\\right)');
      else if (type==='pi') mf.insert('\\pi');
      else if (type==='sin') mf.insert('\\sin\\left(\\right)');
      else if (type==='cos') mf.insert('\\cos\\left(\\right)');
      else if (type==='tan') mf.insert('\\tan\\left(\\right)');
    }
    (function setupKeypads(){
      const ansPad = document.getElementById('ansPad');
      if (ansPad) ansPad.addEventListener('click', function(e){
        const b = e.target.closest('.mini-btn'); if (!b) return;
        try {
          const tx = document.getElementById('ansText'); const mf = document.getElementById('ansMath');
          if (tx) tx.style.display='none'; mf.style.display='';
          // Ø§ÙØªØ­ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ ÙÙˆØ±Ù‹Ø§
          if (mf && mf.focus) mf.focus({ preventScroll: true });
          kbTarget = 'ans';
          if (window.openMathKB) window.openMathKB();
          try {
            if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.visible = true;
            if (mf.showVirtualKeyboard) mf.showVirtualKeyboard(); else if (mf.executeCommand) mf.executeCommand('showVirtualKeyboard');
          } catch{}
        } catch{}
        handleInsMath(b.dataset.ins);
      });
      const ansMf = document.getElementById('ansMath');
      if (ansMf) {
        ansMf.addEventListener('keydown', function(e){
          if ((e.ctrlKey || e.metaKey) && e.key === '/') { e.preventDefault(); handleInsMath('frac'); }
          // Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Enter Ø£Ùˆ Escape: Ø£ØºÙ„Ù‚ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ ÙˆØ£Ø¹Ø¯ Ø§Ù„ØªØ±ÙƒÙŠØ² Ù„Ù„Ù†Øµ
          if (e.key === 'Enter' || e.key === 'Escape') {
            e.preventDefault();
            try { const tx = document.getElementById('ansText'); const mf = document.getElementById('ansMath'); const v = mf && mf.getValue ? String(mf.getValue('latex')||'') : ''; if (tx) tx.value = v; } catch{}
            try { document.activeElement.blur(); } catch{}
            try { if (mf.hideVirtualKeyboard) mf.hideVirtualKeyboard(); else if (mf.executeCommand) mf.executeCommand('hideVirtualKeyboard'); } catch{}
            try { const tx = document.getElementById('ansText'); if (tx) { mf.style.display='none'; tx.style.display=''; tx.focus(); } } catch{}
          }
        });
      }
    })();

    // ====== Interactive Graphing with Plotly + SymPy (via Pyodide) ======
    let pyodideReady = false;
    let renderSeq = 0; // guard async updates
    async function initSymPy(){
      try {
        const status = document.getElementById('sympyStatus'); if (status) status.textContent = (lang==='ar'? 'SymPy: Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„â€¦' : 'SymPy: loadingâ€¦');
        // Important: indexURL must point to the /full/ directory matching the script src
        const pyo = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/' });
        await pyo.loadPackage(['sympy']);
        await pyo.runPythonAsync(`
    import sympy as sp
    x = sp.symbols('x')

    def parse_expr(s):
      return sp.sympify(s, locals={'x': x, 'sin': sp.sin, 'cos': sp.cos, 'tan': sp.tan, 'exp': sp.exp, 'log': sp.log, 'ln': sp.log, 'sqrt': sp.sqrt, 'Abs': sp.Abs, 'abs': sp.Abs})

    def deriv_slope(s, x0):
      f = parse_expr(s)
      df = sp.diff(f, x)
      return float(sp.N(df.subs({x: x0})))

    def integral_value_eps(s, eps):
      f = parse_expr(s)
      val = sp.integrate(f, (x, 0, eps))
      return float(sp.N(val))

    def integral_value_around_a(s, a, eps):
      f = parse_expr(s)
      val = sp.integrate(f, (x, a-eps, a+eps))
      return float(sp.N(val))

    def integral_latex(s):
      f = parse_expr(s)
      F = sp.integrate(f, x)
      return sp.latex(F)

    def diff_latex(s):
      f = parse_expr(s)
      d = sp.diff(f, x)
      return sp.latex(d)

    def integral_def_value(s, a, b):
      f = parse_expr(s)
      val = sp.integrate(f, (x, a, b))
      return float(sp.N(val))

    def solve_calc(raw, mode, at=None):
      try:
        from sympy.parsing.latex import parse_latex as _parse_latex
      except Exception:
        _parse_latex = None

      obj = None
      if _parse_latex is not None:
        try:
          obj = _parse_latex(raw)
        except Exception:
          obj = None

      if obj is None:
        # fallback: try to sympify plain text
        try:
          obj = parse_expr(raw)
        except Exception:
          obj = None

      res = {}
      try:
        if mode == 'diff':
          f = obj if obj is not None else parse_expr(raw)
          # If user pasted an Integral/Derivative, try to get the inner function
          if isinstance(f, sp.Integral):
            f = f.function
          d = sp.diff(f, x)
          res['D_latex'] = sp.latex(d)
          if at is not None:
            try:
              res['D_val'] = float(sp.N(d.subs({x: float(at)})))
            except Exception:
              pass
        else:
          # integral mode
          bounds = None
          f = obj if obj is not None else parse_expr(raw)
          if isinstance(f, sp.Integral):
            # If definite integral, capture bounds
            if len(f.limits) and len(f.limits[0]) == 3:
              a, b = f.limits[0][1], f.limits[0][2]
              try:
                bounds = [float(sp.N(a)), float(sp.N(b))]
              except Exception:
                bounds = None
            f = f.function
          F = sp.integrate(f, x)
          res['F_latex'] = sp.latex(F)
          if bounds is not None:
            try:
              val = sp.integrate(f, (x, bounds[0], bounds[1]))
              res['int_val'] = float(sp.N(val))
              res['bounds'] = bounds
            except Exception:
              res['bounds'] = bounds
      except Exception:
        pass

      import json
      return json.dumps(res)
        `);
        window.pyodide = pyo;
        pyodideReady = true;
        if (status) status.textContent = (lang==='ar'? 'SymPy: Ø¬Ø§Ù‡Ø²' : 'SymPy: ready');
      } catch(e){
        pyodideReady = false;
        const status = document.getElementById('sympyStatus'); if (status) status.textContent = (lang==='ar'? 'SymPy: ØªØ¹Ø°Ù‘Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ (Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ‚Ø±ÙŠØ¨Ø§Øª Ø¹Ø¯Ø¯ÙŠØ©)' : 'SymPy: failed to load (using numeric fallbacks)');
      }
    }

    function bindGraphControls(){
      try {
        const eps = document.getElementById('eps'); const epsVal = document.getElementById('epsVal');
        if (eps) eps.addEventListener('input', ()=>{ const v = parseFloat(eps.value||'0.5'); epsVal.textContent = `Îµ=${v.toFixed(2)}`; scheduleRenderGraph(); });
        const oi = document.getElementById('optIntegral'); if (oi) oi.addEventListener('change', scheduleRenderGraph);
        const od = document.getElementById('optDerivative'); if (od) od.addEventListener('change', scheduleRenderGraph);
        const osq = document.getElementById('optSqueeze'); if (osq) osq.addEventListener('change', scheduleRenderGraph);
        const oll = document.getElementById('optLimitLine'); if (oll) oll.addEventListener('change', scheduleRenderGraph);
        const x0t = document.getElementById('x0Text'); if (x0t) x0t.addEventListener('input', scheduleRenderGraph);
        const zIn = document.getElementById('zoomIn'); if (zIn) zIn.addEventListener('click', ()=> adjustZoom(0.7));
        const zOut = document.getElementById('zoomOut'); if (zOut) zOut.addEventListener('click', ()=> adjustZoom(1.3));
        const zR = document.getElementById('resetView'); if (zR) zR.addEventListener('click', ()=> resetView());
        const em = document.getElementById('exprMath'); const et = document.getElementById('exprText');
        if (em) em.addEventListener('input', function(){ scheduleRenderGraph(); scheduleSolutionGraph(); scheduleTrainGraph(); });
        if (et) et.addEventListener('input', function(){ scheduleRenderGraph(); scheduleSolutionGraph(); scheduleTrainGraph(); });
        const pm = document.getElementById('pointMath'); const pt = document.getElementById('pointText');
        if (pm) pm.addEventListener('input', function(){ scheduleRenderGraph(); scheduleSolutionGraph(); scheduleTrainGraph(); });
        if (pt) pt.addEventListener('input', function(){ scheduleRenderGraph(); scheduleSolutionGraph(); scheduleTrainGraph(); });
      } catch {}
    }

    let graphRange = 2.0;
    function currentXDomain(){ return [-graphRange, graphRange]; }
    function adjustZoom(factor){ graphRange = Math.max(0.2, Math.min(20, graphRange * factor)); if (mode==='graph') renderGraph(); }
    function resetView(){ graphRange = 2.0; if (mode==='graph') renderGraph(); }

    async function renderGraph(){
      const seq = ++renderSeq;
      const expr = getExprInput();
      const a = getApproachValue();
      const showInt = !!(document.getElementById('optIntegral')?.checked);
      const showDer = !!(document.getElementById('optDerivative')?.checked);
      const showSq  = !!(document.getElementById('optSqueeze')?.checked);
      const showL   = !!(document.getElementById('optLimitLine')?.checked);
      let x0Raw = String(document.getElementById('x0Text')?.value||'').trim();
      let x0 = (x0Raw? evalLatexNumeric(x0Raw) : a);
      if (!Number.isFinite(x0)) x0 = a;
      const [xmin, xmax] = currentXDomain();
      const baseN = (window.innerWidth <= 640) ? 240 : 400;
      const len = Math.max(1, expr.length);
      const factor = Math.max(0.6, Math.min(1.0, 280/(len+80)));
      const N = Math.round(baseN * factor);
      let f;
      try { f = compileExprFn(expr); } catch { f = null; }
      const xs = new Array(N);
      const ys = new Array(N);
      let yMin = Infinity, yMax = -Infinity;
      const addExtentFrom = (arr)=>{ for (const v of arr){ if (Number.isFinite(v)){ if (v < yMin) yMin = v; if (v > yMax) yMax = v; } } };
      for (let i=0;i<N;i++){
        const x = xmin + (i*(xmax-xmin))/(N-1);
        xs[i] = x;
        try { ys[i] = f ? f(x) : evalAt(expr, x); } catch { ys[i] = NaN; }
      }
      addExtentFrom(ys);
      const curve = { x: xs, y: ys, mode: 'lines', name: (lang==='ar'? 'Ø§Ù„Ø¯Ø§Ù„Ø©' : 'Function'), line: { color: '#5b7cff', width: 2 } };
      const data = [curve];
      let Lval = NaN;
      try {
        if (f) Lval = estimateLimitWithFn(f, a); else Lval = estimateLimit(expr, a);
        data.push({ x: [0], y: [Lval], mode: 'markers', name: (lang==='ar'? 'Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¹Ù†Ø¯ 0' : 'Limit at 0'), marker: { color: '#a78bfa', size: 10, symbol: 'circle-open' } });
        if (Number.isFinite(Lval)) addExtentFrom([Lval]);
      } catch {}
            // optional horizontal limit line
            if (showL && Number.isFinite(Lval)){
              data.push({ x: [xmin, xmax], y: [Lval, Lval], mode: 'lines', name: (lang==='ar'? 'Ø§Ù„Ø­Ø¯ L' : 'Limit L'), line: { color: '#6b7280', width: 1.5, dash: 'dot' } });
            }
            // optional squeeze bounds for forms m(x)*sin(1/(x-a)) or m(x)*cos(1/(x-a)) (also supports 1/x when a=0)
            if (showSq){
              const usesSinX = /sin\s*\(\s*1\s*\/\s*x\s*\)/.test(expr) || /Math\.sin\s*\(\s*1\s*\/\s*x\s*\)/.test(expr);
              const usesCosX = /cos\s*\(\s*1\s*\/\s*x\s*\)/.test(expr) || /Math\.cos\s*\(\s*1\s*\/\s*x\s*\)/.test(expr);
              const usesSinShift = /sin\s*\(\s*1\s*\/\s*\(\s*x\s*-\s*a\s*\)\s*\)/.test(expr) || /Math\.sin\s*\(\s*1\s*\/\s*\(\s*x\s*-\s*a\s*\)\s*\)/.test(expr);
              const usesCosShift = /cos\s*\(\s*1\s*\/\s*\(\s*x\s*-\s*a\s*\)\s*\)/.test(expr) || /Math\.cos\s*\(\s*1\s*\/\s*\(\s*x\s*-\s*a\s*\)\s*\)/.test(expr);
              const usesSin = usesSinX || usesSinShift; const usesCos = usesCosX || usesCosShift;
              if (usesSin || usesCos){
                const xi=[], yu=[], yl=[];
                for (let i=0;i<N;i++){
                  const x = xs[i];
                  const near = (usesSinShift || usesCosShift) ? (x - a) : x;
                  const denom = usesSin ? Math.sin(1/near) : Math.cos(1/near);
                  if (!Number.isFinite(denom) || Math.abs(denom) < 1e-6) { xi.push(x); yu.push(NaN); yl.push(NaN); continue; }
                  let y = ys[i];
                  if (!Number.isFinite(y)) { xi.push(x); yu.push(NaN); yl.push(NaN); continue; }
                  const m = Math.abs(y/denom);
                  xi.push(x); yu.push(m); yl.push(-m);
                }
                data.push({ x: xi, y: yu, mode: 'lines', name: (lang==='ar'? '+Ø³Ù†Ø¯Ø©' : '+upper bound'), line: { color: '#22c55e', width: 1.5 } });
                data.push({ x: xi, y: yl, mode: 'lines', name: (lang==='ar'? '-Ø³Ù†Ø¯Ø©' : '-lower bound'), line: { color: '#ef4444', width: 1.5 } });
                addExtentFrom(yu); addExtentFrom(yl);
              }
            }
      const areaLbl = document.getElementById('areaLabel'); if (areaLbl) areaLbl.textContent = (lang==='ar'? 'Ø§Ù„Ù…Ø³Ø§Ø­Ø© ~ â€”' : 'Area ~ â€”');
      if (showInt){
        const eps = parseFloat(document.getElementById('eps')?.value||'0.5');
        const xA = Math.max(xmin, a - eps), xB = Math.min(xmax, a + eps);
        const n2 = Math.max(50, Math.round(N*(xB-xA)/(xmax-xmin)));
        const xi = [], yi = [];
        for (let i=0;i<n2;i++){
          const x = xA + (i*(xB-xA))/(n2-1);
          xi.push(x);
          try { yi.push(f ? f(x) : evalAt(expr, x)); } catch { yi.push(NaN); }
        }
        data.push({ x: xi.concat([xB,xA]), y: yi.concat([0,0]), fill: 'toself', type: 'scatter', name: (lang==='ar'? 'Ù…Ø³Ø§Ø­Ø© Ø­ÙˆÙ„ a' : 'Area around a'), line: { color: 'rgba(167,139,250,.6)' }, fillcolor: 'rgba(167,139,250,.25)' });
        addExtentFrom(yi);
        try {
          if (pyodideReady){
            const val = await window.pyodide.runPythonAsync(`integral_value_around_a(${JSON.stringify(expr)}, ${a}, ${eps})`);
            if (seq === renderSeq) areaLbl.textContent = (lang==='ar'? `Ø§Ù„Ù…Ø³Ø§Ø­Ø© ~ ${(+val).toFixed(6)}` : `Area ~ ${(+val).toFixed(6)}`);
          }
        } catch {}
      }
      if (showDer){
        let m = NaN;
        try {
          if (pyodideReady){
            m = await window.pyodide.runPythonAsync(`deriv_slope(${JSON.stringify(expr)}, ${x0})`);
          }
        } catch {}
        if (!Number.isFinite(m)){
          try {
            const h = 1e-5; m = ((f?f(x0+h):evalAt(expr, x0+h)) - (f?f(x0-h):evalAt(expr, x0-h)))/(2*h);
          } catch {}
        }
        if (Number.isFinite(m)){
          let y0 = NaN; try { y0 = f ? f(x0) : evalAt(expr, x0); } catch {}
          if (Number.isFinite(y0)){
            const txs = [xmin, xmax];
            const tys = txs.map(x=> y0 + m*(x - x0));
            data.push({ x: txs, y: tys, mode: 'lines', name: (lang==='ar'? 'Ø®Ø· Ø§Ù„Ù…Ù…Ø§Ø³' : 'Tangent line'), line: { color: '#10b981', width: 2, dash: 'dash' } });
            data.push({ x: [x0], y: [y0], mode: 'markers', name: (lang==='ar'? 'Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù…Ø§Ø³' : 'Tangent point'), marker: { color: '#10b981', size: 9 } });
            addExtentFrom(tys); addExtentFrom([y0]);
          }
        }
      }
      const isMobile = window.innerWidth <= 640;
      if (!(yMin < yMax)) { yMin = -1; yMax = 1; }
      const padY = Math.max(0.1, (yMax - yMin) * 0.08);
      const fontColor = (theme === 'light') ? '#0f172a' : '#e5e7eb';
      const annotations = [];
      if (Number.isFinite(Lval)) {
        annotations.push({ x: 0, y: Lval, text: (lang==='ar'? `L â‰ˆ ${Lval.toFixed(4)}` : `L â‰ˆ ${Lval.toFixed(4)}`),
          xanchor: 'left', yanchor: 'bottom', showarrow: true, arrowhead: 2, ax: 16, ay: -16, font: { color: fontColor, size: isMobile?11:12 } });
      }
      const layout = {
        margin: isMobile ? { l: 28, r: 14, t: 6, b: 34 } : { l: 40, r: 20, t: 10, b: 40 },
        paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: fontColor, size: isMobile?12:14 },
        xaxis: { title: (lang==='ar'? 'Ø§Ù„Ù…ØªØºÙŠØ± x' : 'x'), range: [xmin, xmax], gridcolor: 'rgba(255,255,255,0.12)', zeroline: true, zerolinecolor: 'rgba(255,255,255,0.2)' },
        yaxis: { title: '', range: [yMin - padY, yMax + padY], gridcolor: 'rgba(255,255,255,0.12)', zeroline: true, zerolinecolor: 'rgba(255,255,255,0.2)' },
        showlegend: true,
        legend: isMobile ? { orientation: 'v', x: 0, y: 1.02 } : { orientation: 'h' },
        annotations,
        shapes: [ { type: 'line', x0: a, x1: a, y0: yMin - padY, y1: yMax + padY, line: { color: '#6b7280', width: 1, dash: 'dot' } } ]
      };
      try { annotations.push({ xref:'paper', yref:'paper', x:-0.06, y:0.5, text:'y', showarrow:false, textangle:0, align:'center', font:{ color:fontColor, size:isMobile?12:14 }, captureevents:false }); } catch{}
      // Ensure the graph height suits the current viewport, then render responsively
      fitGraphHeight();
      try {
        Plotly.react('graph', data, layout, { responsive: true, displaylogo: false, scrollZoom: true });
      } catch {}
    }

    // ====== Read-only compact graph for solution ======
    async function renderSolutionGraph(expr, a, Lhint, opts){
      const target = (opts && opts.targetId) ? document.getElementById(opts.targetId) : document.getElementById('solutionGraph');
      if (!target) return;
      const isMobile = window.innerWidth <= 640;
      // domain centered at a
      const R = 2.0; const xmin = a - R, xmax = a + R;
      const quality = (opts && opts.quality) || 'normal';
      const baseN = quality==='high' ? (isMobile ? 420 : 760) : (isMobile ? 300 : 540);
      const len = Math.max(1, expr.length); const factor = Math.max(0.6, Math.min(1.0, 280/(len+80)));
      const N = Math.round(baseN * factor);
      let f; try { f = compileExprFn(expr); } catch { f = null; }
      const xs = new Array(N); const ys = new Array(N);
      let yMin = Infinity, yMax = -Infinity;
      const addExt = (arr)=>{ for (const v of arr){ if (Number.isFinite(v)){ yMin = Math.min(yMin, v); yMax = Math.max(yMax, v); } } };
      // Cluster more samples near x=a for higher accuracy around the limit
      for (let i=0;i<N;i++){
        const t = (i/(N-1))*2 - 1; // [-1,1]
        const k = 2.0; // concentration factor
        const s = Math.tanh(k*t)/Math.tanh(k); // still in [-1,1], denser near 0
        const x = a + (xmax-a)*((s+1)/2) + (xmin-a)*((1-s)/2);
        xs[i]=x;
        try { ys[i] = f ? f(x) : evalAt(expr, x); } catch { ys[i] = NaN; }
      }
      addExt(ys);
      let L = NaN; try { L = Number.isFinite(Lhint)?Lhint : (f? estimateLimitWithFn(f,a) : estimateLimit(expr,a)); } catch {}
      if (Number.isFinite(L)) addExt([L]);
      // derivative at a
      let m = NaN; try { if (pyodideReady){ m = await window.pyodide.runPythonAsync(`deriv_slope(${JSON.stringify(expr)}, ${a})`); } } catch{}
      if (!Number.isFinite(m)) { try { const h=1e-5; m = ((f?f(a+h):evalAt(expr,a+h)) - (f?f(a-h):evalAt(expr,a-h)))/(2*h); } catch{} }
      let y0 = NaN; try { y0 = f?f(a):evalAt(expr,a); } catch{}
      const curve = { x: xs, y: ys, mode: 'lines', name: (lang==='ar'? 'Ø§Ù„Ø¯Ø§Ù„Ø©' : 'Function'), line: { color: '#5b7cff', width: 2 } };
      const data = [curve];
      if (Number.isFinite(L)) data.push({ x:[a], y:[L], mode:'markers', name:(lang==='ar'?'Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø¹Ù†Ø¯ a':'Limit at a'), marker:{ color:'#a78bfa', size:9, symbol:'circle-open' }});
      // limit line
      if (Number.isFinite(L)) data.push({ x:[xmin,xmax], y:[L,L], mode:'lines', name:(lang==='ar'?'Ø§Ù„Ø­Ø¯ L':'Limit L'), line:{ color:'#6b7280', width:1.5, dash:'dot' }});
      // tangent line
      if (Number.isFinite(m) && Number.isFinite(y0)){
        const txs=[xmin,xmax]; const tys=txs.map(x=> y0 + m*(x-a));
        data.push({ x:txs, y:tys, mode:'lines', name:(lang==='ar'?'Ø®Ø· Ø§Ù„Ù…Ù…Ø§Ø³':'Tangent'), line:{ color:'#10b981', width:2, dash:'dash' }});
        data.push({ x:[a], y:[y0], mode:'markers', name:(lang==='ar'?'Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù…Ø§Ø³':'Tangent point'), marker:{ color:'#10b981', size:8 }});
        addExt(tys); addExt([y0]);
      }
      // symmetric integral shading around a
      const eps = 0.6; const xA = Math.max(xmin, a-eps), xB = Math.min(xmax, a+eps);
      const n2 = Math.max(40, Math.round(N*(xB-xA)/(xmax-xmin)));
      const xi=[], yi=[]; for (let i=0;i<n2;i++){ const x = xA + (i*(xB-xA))/(n2-1); xi.push(x); try{ yi.push(f?f(x):evalAt(expr,x)); } catch { yi.push(NaN); } }
      data.push({ x: xi.concat([xB,xA]), y: yi.concat([0,0]), type:'scatter', fill:'toself', name:(lang==='ar'?'Ù…Ø³Ø§Ø­Ø© Ø­ÙˆÙ„ a':'Area around a'), line:{ color:'rgba(167,139,250,.6)' }, fillcolor:'rgba(167,139,250,.25)' });
      addExt(yi);
      if (!(yMin<yMax)) { yMin=-1; yMax=1; }
      const padY = Math.max(0.1, (yMax-yMin)*0.08);
      const fontColor = (theme==='light')? '#0f172a' : '#e5e7eb';
      const layout = {
        margin: isMobile? {l:24,r:10,t:6,b:30} : {l:36,r:18,t:10,b:36},
        paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', font:{ color: fontColor, size: isMobile?12:13 },
        xaxis:{ title:(lang==='ar'?'Ø§Ù„Ù…ØªØºÙŠØ± x':'x'), range:[xmin,xmax], gridcolor:'rgba(255,255,255,0.12)', zeroline:true, zerolinecolor:'rgba(255,255,255,0.2)' },
        yaxis:{ title:{ text:'y', font:{ family:'Arial, Segoe UI, Tahoma, sans-serif', size:isMobile?12:13 } }, range:[yMin-padY, yMax+padY], gridcolor:'rgba(255,255,255,0.12)', zeroline:true, zerolinecolor:'rgba(255,255,255,0.2)' },
        legend:{ orientation: isMobile?'v':'h' },
        shapes:[ { type:'line', x0:a, x1:a, y0:yMin-padY, y1:yMax+padY, line:{ color:'#6b7280', width:1, dash:'dot' } } ]
      };
      try { Plotly.react(target, data, layout, { responsive:true, displayModeBar:false }); } catch{}
    }

    function renderCompactTrainGraph(expr, a, L){
      renderSolutionGraph(expr, a, L, { quality: 'high', targetId: 'trainGraph' });
    }

    // Debounced renderer to avoid excessive redraws during typing/sliding
    const scheduleRenderGraph = debounce(()=>{ if (mode==='graph') renderGraph(); }, 180);
    const scheduleSolutionGraph = debounce(()=>{
      if (mode !== 'solve') return;
      const target = document.getElementById('solutionGraph'); if (!target) return;
      try {
        const expr = getExprInput(); const a = getApproachValue();
        let L = NaN; try { const f = compileExprFn(expr); L = estimateLimitWithFn(f, a); } catch { L = estimateLimit(expr, a); }
        renderSolutionGraph(expr, a, L);
      } catch {}
    }, 220);
    const scheduleTrainGraph = debounce(()=>{
      // disabled: do nothing in training mode
      return;
    }, 220);

    // re-render graph when new training question is created
    const __origNewQuestion__ = newQuestion;
    newQuestion = function(){
      try { setRandomApproach(); } catch{}
      __origNewQuestion__();
      try { if (mode==='graph') renderGraph(); } catch{}
      try { const tg = document.getElementById('trainGraph'); if (tg) tg.style.display = 'none'; } catch{}
    };

    // Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª { ... } ÙÙŠ LaTeX
    function findBraceGroup(str, start){
      let i = start;
      while (i < str.length && str[i] !== '{') i++;
      if (i >= str.length || str[i] !== '{') return null;
      let depth = 0; let j = i + 1; const begin = j;
      while (j < str.length){
        const ch = str[j];
        if (ch === '\\') { j += 2; continue; }
        if (ch === '{') depth++;
        else if (ch === '}') { if (depth === 0) return { content: str.slice(begin, j), end: j }; else depth--; }
        j++;
      }
      return null;
    }
    function replaceAllFracLatex(s){
      // Ø·Ø¨Ø¹ Ù…ÙˆØ­Ù‘Ø¯ Ù„Ù€ \frac, \dfrac, \tfrac Ù…Ø¹ Ø¯Ø¹Ù… ØªØ¯Ø§Ø®Ù„ Ø§Ù„Ø£Ù‚ÙˆØ§Ø³
      s = s.replace(/\\dfrac/g, '\\frac').replace(/\\tfrac/g, '\\frac');
      let i = 0;
      while (true){
        const idx = s.indexOf('\\frac', i);
        if (idx === -1) break;
        let k = idx + 5; // length of "\\frac"
        const num = findBraceGroup(s, k);
        if (!num) { i = idx + 5; continue; }
        const den = findBraceGroup(s, num.end + 1);
        if (!den) { i = idx + 5; continue; }
        const numJS = `(${latexToJSExpr(num.content)})`;
        const denJS = `(${latexToJSExpr(den.content)})`;
        const repl = `${numJS}/${denJS}`;
        s = s.slice(0, idx) + repl + s.slice(den.end + 1);
        i = idx + repl.length;
      }
      return s;
    }
    // ØªØ­ÙˆÙŠÙ„ LaTeX Ø¥Ù„Ù‰ ØªØ¹Ø¨ÙŠØ± JS Ø«Ù… Ø¥Ù„Ù‰ Ù‚ÙŠÙ…Ø© Ø±Ù‚Ù…ÙŠØ©
    function latexToJSExpr(lx){
      if (!lx) return '';
      let s = lx;
      s = s.replace(/\\left|\\right/g, '');
      // fractions (robust, ÙŠØ¯Ø¹Ù… Ø§Ù„ØªØ¯Ø§Ø®Ù„ Ùˆ x^{2} Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒØ³Ø±)
      s = replaceAllFracLatex(s);
      // sqrt
      const sqrt = /\\sqrt\{([^{}]+)\}/g;
      while (sqrt.test(s)) s = s.replace(sqrt, (m,a)=>`(${latexToJSExpr(a)})**0.5`);
      // trig
      s = s.replace(/\\sin\s*\(([^)]+)\)/g, (m,a)=>`Math.sin(${latexToJSExpr(a)})`);
      s = s.replace(/\\cos\s*\(([^)]+)\)/g, (m,a)=>`Math.cos(${latexToJSExpr(a)})`);
      s = s.replace(/\\tan\s*\(([^)]+)\)/g, (m,a)=>`Math.tan(${latexToJSExpr(a)})`);
      s = s.replace(/\\ln\s*\(([^)]+)\)/g, (m,a)=>`Math.log(${latexToJSExpr(a)})`);
      s = s.replace(/\\log\s*\(([^)]+)\)/g, (m,a)=>`Math.log(${latexToJSExpr(a)})`);
      s = s.replace(/\\exp\s*\(([^)]+)\)/g, (m,a)=>`Math.exp(${latexToJSExpr(a)})`);
      // pi
      s = s.replace(/\\pi/g, 'Math.PI');
      // powers like x^{2}
      s = s.replace(/([0-9A-Za-z_\)]+)\^\{([^}]+)\}/g, (m,base,exp)=>`${base}**(${latexToJSExpr(exp)})`);
      // absolute value using |...|
      s = s.replace(/\|([^|]+)\|/g, (m,a)=>`Math.abs(${latexToJSExpr(a)})`);
      // cleanup braces to parentheses
      s = s.replace(/\{([^{}]+)\}/g, (m,a)=>`(${a})`);
      s = s.replace(/\\cdot/g, '*');
      // normalize unicode minus to ASCII minus
      s = s.replace(/\u2212/g, '-');
      // implicit multiplication: 3x -> 3*x , 2 (x+1) -> 2*(x+1) , (x+1)2 -> (x+1)*2 , )( -> )*(
      s = s.replace(/([0-9])\s*([A-Za-z])/g, '$1*$2');
      s = s.replace(/([0-9\)])\s*\(/g, '$1*(');
      s = s.replace(/\)\s*([0-9A-Za-z])/g, ')*$1');
      return s;
    }
    // Cache heavy LaTeXâ†’JS conversions to avoid freezes on long inputs
    const LATEX_CACHE = new Map();
    function latexToJSExprCached(lx){
      try {
        if (LATEX_CACHE.has(lx)) return LATEX_CACHE.get(lx);
        const out = latexToJSExpr(lx);
        LATEX_CACHE.set(lx, out);
        return out;
      } catch { return latexToJSExpr(lx); }
    }
    function evalLatexNumeric(lx){
      try{
        const expr = latexToJSExpr(lx).trim();
        if (!expr) return NaN;
        const ok = /^[0-9\s+\-*/().A-Za-z_]*$/.test(expr);
        if (!ok) return NaN;
        // eslint-disable-next-line no-new-func
        return Function(`return (${expr});`)();
      }catch{ return NaN; }
    }
    // HUD: Ø¹Ø±Ø¶ xâ†’a ØªØ­Øª Ø­Ù‚Ù„ Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨
    function updateApproachHUD(){
      const hud = document.getElementById('approachHUD'); if (!hud) return;
      const aText = (typeof getApproachLabel==='function') ? getApproachLabel() : '0';
      const content = `\\(x \\to ${aText || '0'}\\)`;
      hud.innerHTML = content;
      if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
    }
    // ØªÙˆÙ„ÙŠØ¯ Ù†Ù‚Ø·Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    function pickRandomApproach(){
      const v = +(Math.random()*4 - 2).toFixed(2); // [-2,2]
      return Number.isFinite(v) ? v : 0;
    }
    function setRandomApproach(){
      try {
        const a = pickRandomApproach();
        const pm = document.getElementById('pointMath');
        const pt = document.getElementById('pointText');
        if (pt) pt.value = String(a);
        if (pm && pm.setValue) pm.setValue(String(a), { suppressChangeNotifications: true });
        pointSel = String(a);
      } catch{}
      try { updateApproachHUD(); } catch{}
      try { applyLang(); } catch{}
    }
    // Ù‚Ø±Ø§Ø¡Ø© Ù‚ÙŠÙ…Ø© Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø¨ Ù…Ù† Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ/Ø§Ù„Ù†ØµÙŠ
    function getApproachInput(){
      const pm = document.getElementById('pointMath');
      const pt = document.getElementById('pointText');
      const container = document.getElementById('point-field-container');
      let v = '';
      try {
        const containerHidden = container && container.style.display === 'none';
        if (containerHidden) {
          v = String(pt ? pt.value||'' : '');
        } else if (pm && pm.getValue) {
          v = String(pm.getValue('latex')||'');
          if (!v) v = String(pt ? pt.value||'' : '');
        } else {
          v = String(pt ? pt.value||'' : '');
        }
      } catch {
        v = String(pt ? pt.value||'' : '');
      }
      return String(v||'').trim();
    }
    function getApproachValue(){
      const s = getApproachInput();
      if (!s) return 0;
      const val = evalLatexNumeric(s);
      return (typeof val==='number' && Number.isFinite(val)) ? val : 0;
    }
    // Normalize any explicit shifts like (x - c) or (x + c) to use current a
    // Only rewrites when the linear term is parenthesized to avoid unintended changes (e.g., 2*x-1 stays intact)
    function normalizeExprForA(expr, a){
      try{
        if (!expr) return expr;
        const A = Number(a);
        if (!Number.isFinite(A)) return expr;
        // keep a concise numeric string
        const aStr = (Math.abs(A - Math.round(A)) < 1e-9) ? String(Math.round(A)) : String(parseFloat(A.toFixed(8)));
        // Replace any parenthesized linear term of the form (x Â± number)
        // Examples matched: (x-1), (x + 2.5), ( x- 3 )
        return expr.replace(/\(\s*x\s*[+\-]\s*\d+(?:\.\d+)?\s*\)/g, ()=>`(x - ${aStr})`);
      }catch{ return expr; }
    }
    function approachTextToLatex(txt){
      let t = String(txt||'');
      t = t.replace(/pi/gi, '\\pi');
      t = t.replace(/\*\*/g, '^');
      t = t.replace(/\*/g, ' ');
      return t;
    }
    function getApproachLabel(){
      const pm = document.getElementById('pointMath');
      const pt = document.getElementById('pointText');
      const container = document.getElementById('point-field-container');
      try {
        const containerHidden = container && container.style.display === 'none';
        if (!containerHidden && pm && pm.getValue) {
          const lx = String(pm.getValue('latex')||'').trim();
          if (lx) return lx;
        }
        const raw = String(pt ? pt.value||'' : '').trim();
        return raw ? approachTextToLatex(raw) : '0';
      } catch { return '0'; }
    }
    async function initAudioHQ(){
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // fetch an existing file (applause.wav) to avoid 404s
        const resp = await fetch('audio/applause.wav', { cache: 'no-store' });
        const buf = await resp.arrayBuffer();
        applauseBuffer = await audioCtx.decodeAudioData(buf);
        return true;
      } catch(e) { return false; }
    }
    // Menu tip controls (anchored to answer menu)
    function showMenuTip(){ const el = document.getElementById('ansMenuTip'); if (!el) return; el.style.display='block'; }
    function hideMenuTip(mark){ const el = document.getElementById('ansMenuTip'); if (!el) return; el.style.display='none'; if (mark) { try { localStorage.setItem('menuTipSeen','1'); } catch {} } }
    (function bindMenu(){ const b = document.getElementById('ansMenuBtn'); const tip = document.getElementById('ansMenuTip'); if (!b || !tip) return; b.addEventListener('mouseenter', showMenuTip); b.addEventListener('mouseleave', hideMenuTip); b.addEventListener('click', ()=>{ if (tip.style.display==='none' || tip.style.display==='') showMenuTip(); else hideMenuTip(true); }); })();
    function playApplauseHQ(){
      // returns true if played via WebAudio
      if (!audioCtx || !applauseBuffer) return false;
      try {
        const src = audioCtx.createBufferSource(); src.buffer = applauseBuffer;
        const gain = audioCtx.createGain(); gain.gain.value = 0.0;
        const comp = audioCtx.createDynamicsCompressor();
        comp.threshold.value = -24; comp.knee.value = 30; comp.ratio.value = 6; comp.attack.value = 0.003; comp.release.value = 0.25;
        const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 8000; lp.Q.value = 0.7;
        src.connect(comp); comp.connect(lp); lp.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime; gain.gain.cancelScheduledValues(now); gain.gain.setValueAtTime(0.0, now);
        gain.gain.linearRampToValueAtTime(1.0, now + 0.6);
        src.start();
        return true;
      } catch(e) { return false; }
    }
    window.addEventListener('click', async ()=>{ try{ if(!audioCtx || !applauseBuffer) await initAudioHQ(); }catch{} }, { once: true });
  </script>
</body>
</html>

